{"version":3,"sources":["node_modules/@ursys/core/_dist/client-cjs.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/scripts/ursys-core.js","sourcesContent":["\nrequire.register(\"@ursys/core/_dist/client-cjs.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"@ursys/core\");\n  (function() {\n    var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// _ur/common/util-text.ts\nvar require_util_text = __commonJS({\n  \"_ur/common/util-text.ts\"(exports, module2) {\n    function PreprocessDataText(str) {\n      let normalizedStr = str.replace(/\\r\\n|\\r/g, \"\\n\");\n      normalizedStr = normalizedStr.split(\"\\n\").map((line) => line.replace(/\\s+$/, \"\")).map((line) => line.replace(/^\\s+/, \"\")).join(\"\\n\");\n      normalizedStr = normalizedStr.replace(/\\t/g, \"  \");\n      let lines = normalizedStr.split(\"\\n\");\n      const processDelimited = (line, delimiter) => {\n        let parts = line.split(delimiter);\n        for (let i = 0; i < parts.length; i++) {\n          parts[i] = parts[i].trim();\n          parts[i] = parts[i].replace(/\\s+/g, \" \");\n        }\n        return parts.join(delimiter);\n      };\n      for (let i = 0; i < lines.length; i++) {\n        lines[i] = processDelimited(lines[i], \",\");\n        lines[i] = processDelimited(lines[i], \":\");\n      }\n      normalizedStr = lines.join(\"\\n\").trim();\n      return normalizedStr + \"\\n\";\n    }\n    module2.exports = {\n      PreprocessDataText\n    };\n  }\n});\n\n// _ur/browser-client/@client.ts\nvar client_exports = {};\n__export(client_exports, {\n  CLASS: () => CLASS,\n  CLIENT_EP: () => urnet_browser_exports,\n  CONSTANT: () => CONSTANT,\n  ClientTest: () => ClientTest,\n  ConsoleStyler: () => makeStyleFormatter2,\n  LIB: () => LIB,\n  PROMPTS: () => util_prompts_default,\n  StateMgr: () => class_state_mgr_default,\n  TEXT: () => import_util_text.default\n});\nmodule.exports = __toCommonJS(client_exports);\n\n// _ur/common/declare-colors.ts\nvar TERM_COLORS = {\n  // TOUT = makeTerminalOut(str); TOUT('hi')\n  Reset: \"\\x1B[0m\",\n  Bright: \"\\x1B[1m\",\n  Dim: \"\\x1B[2m\",\n  Underscore: \"\\x1B[4m\",\n  Blink: \"\\x1B[5m\",\n  Reverse: \"\\x1B[7m\",\n  Hidden: \"\\x1B[8m\",\n  //\n  Black: \"\\x1B[30m\",\n  White: \"\\x1B[37m\",\n  Red: \"\\x1B[31m\",\n  Orange: \"\\x1B[38;5;202m\",\n  Yellow: \"\\x1B[33m\",\n  Green: \"\\x1B[32m\",\n  Cyan: \"\\x1B[36m\",\n  Blue: \"\\x1B[34m\",\n  Purple: \"\\x1B[35m\",\n  //\n  BgBlack: \"\\x1B[40m\",\n  BgGray: \"\\x1B[100m\",\n  BgWhite: \"\\x1B[47m\",\n  BgRed: \"\\x1B[41m\",\n  BgOrange: \"\\x1B[48;5;202m\",\n  BgYellow: \"\\x1B[43m\",\n  BgCyan: \"\\x1B[46m\",\n  BgGreen: \"\\x1B[42m\",\n  BgBlue: \"\\x1B[44m\",\n  BgPurple: \"\\x1B[45m\",\n  BgPink: \"\\x1B[105m\",\n  // FORMATS\n  TagBlack: \"\\x1B[30;1m\",\n  TagWhite: \"\\x1B[37;1m\",\n  TagRed: \"\\x1B[41;37m\",\n  TagOrange: \"\\x1B[43;37m\",\n  TagYellow: \"\\x1B[43;30m\",\n  TagGreen: \"\\x1B[42;30m\",\n  TagCyan: \"\\x1B[46;37m\",\n  TagBlue: \"\\x1B[44;37m\",\n  TagPurple: \"\\x1B[45;37m\",\n  TagPink: \"\\x1B[105;1m\",\n  TagGray: \"\\x1B[100;37m\",\n  TagNull: \"\\x1B[2;37m\"\n};\nvar CSS_COMMON = \"padding:3px 5px;border-radius:2px;\";\nvar CSS_COLORS = {\n  Reset: \"color:auto;background-color:auto\",\n  // COLOR FOREGROUND\n  Black: \"color:black\",\n  White: \"color:white\",\n  Red: \"color:red\",\n  Orange: \"color:orange\",\n  Yellow: \"color:orange\",\n  Green: \"color:green\",\n  Cyan: \"color:cyan\",\n  Blue: \"color:blue\",\n  Magenta: \"color:magenta\",\n  Pink: \"color:pink\",\n  // COLOR BACKGROUND\n  TagRed: `color:#000;background-color:#f66;${CSS_COMMON}`,\n  TagOrange: `color:#000;background-color:#fa4;${CSS_COMMON}`,\n  TagYellow: `color:#000;background-color:#fd4;${CSS_COMMON}`,\n  TagGreen: `color:#000;background-color:#5c8;${CSS_COMMON}`,\n  TagCyan: `color:#000;background-color:#2dd;${CSS_COMMON}`,\n  TagBlue: `color:#000;background-color:#2bf;${CSS_COMMON}`,\n  TagPurple: `color:#000;background-color:#b6f;${CSS_COMMON}`,\n  TagPink: `color:#000;background-color:#f9f;${CSS_COMMON}`,\n  TagGray: `color:#fff;background-color:#999;${CSS_COMMON}`,\n  TagNull: `color:#999;border:1px solid #ddd;${CSS_COMMON}`,\n  // COLOR BACKGROUND DARK (BROWSER ONLY)\n  TagDkRed: `color:white;background-color:maroon;${CSS_COMMON}`,\n  TagDkOrange: `color:white;background-color:burntorange;${CSS_COMMON}`,\n  TagDkYellow: `color:white;background-color:brown;${CSS_COMMON}`,\n  TagDkGreen: `color:white;background-color:forestgreen;${CSS_COMMON}`,\n  TagDkCyan: `color:white;background-color:cerulean;${CSS_COMMON}`,\n  TagDkBlue: `color:white;background-color:darkblue;${CSS_COMMON}`,\n  TagDkPurple: `color:white;background-color:indigo;${CSS_COMMON}`,\n  TagDkPink: `color:white;background-color:fuchsia;${CSS_COMMON}`\n};\nTERM_COLORS.TagBuild = TERM_COLORS.TagGray;\nTERM_COLORS.TagError = TERM_COLORS.TagRed;\nTERM_COLORS.TagAlert = TERM_COLORS.TagOrange;\nTERM_COLORS.TagTest = TERM_COLORS.TagRed;\nTERM_COLORS.TagSystem = TERM_COLORS.TagGray;\nTERM_COLORS.TagServer = TERM_COLORS.TagGray;\nTERM_COLORS.TagDatabase = TERM_COLORS.TagCyan;\nTERM_COLORS.TagNetwork = TERM_COLORS.TagCyan;\nTERM_COLORS.TagUR = TERM_COLORS.TagBlue;\nTERM_COLORS.TagURNET = TERM_COLORS.TagBlue;\nTERM_COLORS.TagURMOD = TERM_COLORS.TagBlue;\nTERM_COLORS.TagAppMain = TERM_COLORS.TagGreen;\nTERM_COLORS.TagAppModule = TERM_COLORS.TagGreen;\nTERM_COLORS.TagAppState = TERM_COLORS.TagGreen;\nTERM_COLORS.TagAppCore = TERM_COLORS.TagGreen;\nTERM_COLORS.TagDataCore = TERM_COLORS.TagGreen;\nTERM_COLORS.TagUI = TERM_COLORS.TagPurple;\nTERM_COLORS.TagPhase = TERM_COLORS.TagPink;\nTERM_COLORS.TagEvent = TERM_COLORS.TagPink;\nTERM_COLORS.TagStream = TERM_COLORS.TagPink;\nCSS_COLORS.TagDebug = `color:#fff;background-color:IndianRed;${CSS_COMMON}`;\nCSS_COLORS.TagWarning = `color:#fff;background:linear-gradient(\n  -45deg,\n  rgb(29,161,242),\n  rgb(184,107,107),\n  rgb(76,158,135)\n);${CSS_COMMON}`;\nCSS_COLORS.TagTest = CSS_COLORS.TagRed;\nCSS_COLORS.TagSystem = CSS_COLORS.TagGray;\nCSS_COLORS.TagServer = CSS_COLORS.TagGray;\nCSS_COLORS.TagDatabase = CSS_COLORS.TagCyan;\nCSS_COLORS.TagNetwork = CSS_COLORS.TagCyan;\nCSS_COLORS.TagUR = `color:CornflowerBlue;border:1px solid CornflowerBlue;${CSS_COMMON}`;\nCSS_COLORS.TagURNET = `color:#fff;background-color:MediumSlateBlue;${CSS_COMMON}`;\nCSS_COLORS.TagURMOD = `color:#fff;background:linear-gradient(\n  -45deg,\n  CornflowerBlue 0%,\n  LightSkyBlue 25%,\n  RoyalBlue 100%\n);${CSS_COMMON}`;\nCSS_COLORS.TagAppMain = CSS_COLORS.TagGreen;\nCSS_COLORS.TagAppModule = CSS_COLORS.TagGreen;\nCSS_COLORS.TagAppState = `color:#fff;background-color:Navy;${CSS_COMMON}`;\nCSS_COLORS.TagUI = CSS_COLORS.TagDkOrange;\nCSS_COLORS.TagEvent = CSS_COLORS.TagDkOrange;\nCSS_COLORS.TagStream = CSS_COLORS.TagDkOrange;\nCSS_COLORS.TagPhase = `color:#fff;background-color:MediumVioletRed;${CSS_COMMON}`;\n\n// _ur/common/util-prompts.ts\nvar IS_NODE = typeof window === \"undefined\";\nvar IS_MOBILE = !IS_NODE && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n  navigator.userAgent\n);\nvar DEFAULT_PADDING = IS_NODE ? 10 : 8;\nvar DEFAULT_SPACE = IS_NODE ? \" \".padStart(DEFAULT_PADDING, \" \") : \" \".padStart(DEFAULT_PADDING + 4, \" \");\nvar DEFAULT_COLOR = \"TagNull\";\nvar SHOW = true;\nvar PROMPT_DICT = {\n  // URSYS-RELATED MODULES\n  \"UR\": [SHOW, \"TagRed\"],\n  // SERVERS\n  \"APPSRV\": [SHOW, \"Yellow\"],\n  \"GEMSRV\": [SHOW, \"Yellow\"],\n  // SPECIAL\n  \"-\": [SHOW, \"TagNull\"]\n};\nfunction padString(str, padding = DEFAULT_PADDING) {\n  let len = str.length;\n  const nbsp = String.fromCharCode(160);\n  if (IS_NODE) return `${str.padEnd(padding, \" \")}`;\n  if (padding === 0) return `${str}`;\n  if (len >= padding) str = str.substr(0, padding);\n  else str = str.padEnd(padding, nbsp);\n  return `${str}`;\n}\nfunction m_SetPromptColors(match, color = DEFAULT_COLOR) {\n  if (typeof match !== \"string\") throw Error(\"match prompt must be string\");\n  match = match.trim();\n  if (match === \"\") throw Error(\"match prompt cannot be empty\");\n  let colorTable = IS_NODE ? TERM_COLORS : CSS_COLORS;\n  let validColor = false;\n  validColor = colorTable[color] !== void 0;\n  if (!validColor) colorTable = IS_NODE ? CSS_COLORS : TERM_COLORS;\n  validColor = colorTable[color] !== void 0;\n  if (!validColor)\n    throw Error(`prompt color ${color} is not defined in either table`);\n  PROMPT_DICT[match] = [true, color];\n  return colorTable;\n}\nfunction m_GetEnvColor(prompt, tagColor) {\n  const colorTable = m_SetPromptColors(prompt, tagColor);\n  const [dbg_mode, defcol] = PROMPT_DICT[prompt.trim()] || [SHOW, DEFAULT_COLOR];\n  const ucolor = colorTable[tagColor];\n  const dcolor = colorTable[defcol];\n  const color = ucolor || dcolor;\n  const reset = colorTable.Reset;\n  return [dbg_mode, color, reset];\n}\nfunction m_MakeColorArray(prompt, colorName) {\n  const [dbg, color, reset] = m_GetEnvColor(prompt, colorName);\n  if (!(dbg || IS_NODE)) return [];\n  return IS_NODE ? [`${color}${padString(prompt)}${reset}   `] : [`%c${padString(prompt)}%c `, color, reset];\n}\nfunction m_MakeColorPromptFunction(prompt, colorName, opt = {}) {\n  const textColor = opt.color || \"Reset\";\n  const dim = opt.dim || false;\n  return IS_NODE ? (str, ...args) => {\n    if (args === void 0) args = \"\";\n    let TAG = TERM_COLORS[colorName];\n    let TEXT2 = TERM_COLORS[textColor];\n    let RST = TERM_COLORS.Reset;\n    let PR6 = padString(prompt);\n    if (dim) TEXT2 += TERM_COLORS.Dim;\n    console.log(`${RST}${TAG}${PR6}${RST}${TEXT2}    ${str}`, ...args, RST);\n  } : (str, ...args) => {\n    if (args === void 0) args = \"\";\n    let TEXT2 = TERM_COLORS[textColor];\n    let RST = CSS_COLORS.Reset;\n    let PR6 = padString(prompt);\n    console.log(`%c${PR6}%c%c ${str}`, RST, TEXT2, ...args);\n  };\n}\nfunction makeStyleFormatter(prompt, tagColor) {\n  if (prompt.startsWith(\"UR\") && tagColor === void 0) tagColor = \"TagUR\";\n  let outArray = m_MakeColorArray(prompt, tagColor);\n  if (outArray.length === 0) return () => [];\n  if (IS_MOBILE) outArray = [`${prompt}:`];\n  const f = (str, ...args) => [...outArray, str, ...args];\n  f._ = `\n${DEFAULT_SPACE}`;\n  return f;\n}\nfunction makeTerminalOut(prompt, tagColor = DEFAULT_COLOR) {\n  const wrap = m_MakeColorPromptFunction(prompt, tagColor);\n  wrap.warn = m_MakeColorPromptFunction(prompt, \"TagYellow\", { color: \"Yellow\" });\n  wrap.error = m_MakeColorPromptFunction(prompt, \"TagRed\", { color: \"Red\" });\n  wrap.fail = m_MakeColorPromptFunction(prompt, \"Red\", { color: \"Red\" });\n  wrap.pass = m_MakeColorPromptFunction(prompt, \"Green\", { color: \"Green\" });\n  wrap.info = m_MakeColorPromptFunction(prompt, \"TagGray\", { dim: true });\n  wrap.DIM = \"\\x1B[2m\";\n  wrap.BRI = \"\\x1B[1m\";\n  wrap.RST = \"\\x1B[0m\";\n  return wrap;\n}\nvar util_prompts_default = {\n  makeTerminalOut,\n  makeStyleFormatter,\n  padString\n};\n\n// _ur/browser-client/@client.ts\nvar import_util_text = __toESM(require_util_text());\n\n// _ur/common/class-op-seq.ts\nvar OPSEQS = /* @__PURE__ */ new Map();\nfunction m_ValidateSeqName(sn) {\n  const fn = \"m_ValidateSeqName\";\n  const pcErr = \"name must be PascalCase string\";\n  if (sn === \"\") throw Error(`${fn}: ${pcErr}`);\n  if (sn === void 0) throw Error(`${fn}: ${pcErr}`);\n  if (typeof sn !== \"string\") throw Error(`${fn}: ${pcErr}`);\n  if (sn !== sn[0].toUpperCase() + sn.slice(1)) throw Error(`${fn}: ${pcErr}`);\n  if (sn.trim() !== sn)\n    throw Error(`${fn}: name must not have leading/trailing spaces`);\n}\nfunction m_ValidateActiveSeq(seq) {\n  if (seq instanceof OpSequencer) {\n    if (seq._disposed) throw Error(`sequencer ${seq.seqName} is disposed`);\n    else return;\n  }\n  throw Error(\"not a sequence instance or undefined\");\n}\nfunction m_ValidateNodeName(nn) {\n  const fn = \"m_ValidateNodeName\";\n  if (nn === \"\") throw Error(`${fn}: name must be lc string`);\n  if (nn === void 0) throw Error(`${fn}: name must be lc string`);\n  if (typeof nn !== \"string\") throw Error(`${fn}: name must be lc string`);\n  if (nn !== nn.toLowerCase()) throw Error(`${fn}: name must be lc`);\n  if (nn.trim() !== nn)\n    throw Error(`${fn}: name must not have leading/trailing spaces`);\n}\nvar OpSequencer = class _OpSequencer {\n  // true if disposed\n  constructor(seqName) {\n    __publicField(this, \"ops\");\n    // array of operations\n    __publicField(this, \"seqName\");\n    // sequencer name\n    __publicField(this, \"lastOp\");\n    // last operation\n    __publicField(this, \"currentOp\");\n    // current operation\n    __publicField(this, \"opIndex\");\n    // current operation index\n    __publicField(this, \"opsMap\");\n    // map opname to index in ops array\n    __publicField(this, \"subs\");\n    // map opname to set of subscribers\n    __publicField(this, \"_disposed\");\n    m_ValidateSeqName(seqName);\n    seqName = seqName.trim().toUpperCase();\n    if (OPSEQS.has(seqName)) {\n      console.warn(\n        `(not an error) '${seqName}' construction duplicate, returning existing instance`\n      );\n      return OPSEQS.get(seqName);\n    }\n    this.seqName = seqName;\n    this.ops = [];\n    this.opsMap = /* @__PURE__ */ new Map();\n    this.opIndex = -1;\n    this.currentOp = null;\n    this.lastOp = null;\n    this.subs = /* @__PURE__ */ new Map();\n    this._disposed = false;\n    OPSEQS.set(seqName, this);\n  }\n  /* --- add nodes --- */\n  /** given nodeName and a source TOpNode, add a clone of the source node to the sequencer */\n  addOp(name, data, opt) {\n    const fn = \"addOp\";\n    if (data === void 0) throw Error(`${fn}: arg2 must be TOpNode`);\n    if (typeof name !== \"string\") throw Error(`${fn}: arg1 must be name:string`);\n    if (typeof data._name === \"string\") throw Error(`${fn}: node ${name} reused`);\n    if (data._index !== void 0) throw Error(`${fn}: node ${name} reused`);\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(name);\n    if (this.opIndex !== -1) throw Error(`${fn}: sequencer already started`);\n    if (this.hasOp(name)) throw Error(`${fn}: node '${name}' already exists`);\n    const index = this.ops.length;\n    this.opsMap.set(name, index);\n    const newData = { ...data };\n    if (opt == null ? void 0 : opt.mutable) Object.freeze(newData);\n    const newNode = {\n      _opIndex: index,\n      _seqName: this.seqName,\n      _opName: name,\n      data: newData\n    };\n    this.ops.push(newNode);\n    return newNode;\n  }\n  deleteOp(name) {\n    const fn = \"deleteOp\";\n    console.error(`${fn}: not implemented by design`);\n  }\n  /* --- access operations --- */\n  data(key) {\n    m_ValidateActiveSeq(this);\n    if (typeof key === \"string\") return this.currentOp.data[key];\n    return this.currentOp.data;\n  }\n  length() {\n    m_ValidateActiveSeq(this);\n    return this.ops.length;\n  }\n  /* --- sequencer operations --- */\n  start() {\n    const fn = \"start\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex !== -1) throw Error(`${fn}: sequencer already started`);\n    if (this.ops.length === 0) throw Error(`${fn}: no operations to run`);\n    this.opIndex = 0;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  current() {\n    const fn = \"current\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1) throw Error(`${fn}: sequencer not started`);\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  stop() {\n    const fn = \"stop\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1) throw Error(\"stop: sequencer not started\");\n    this.opIndex = -1;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  next() {\n    const fn = \"next\";\n    if (this.opIndex === -1) return this.start();\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === this.ops.length - 1) return void 0;\n    ++this.opIndex;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  previous() {\n    const fn = \"previous\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1) throw Error(`${fn}: sequencer not started`);\n    if (this.opIndex === 0) return void 0;\n    --this.opIndex;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  /* --- node events --- */\n  subscribe(opName, subf) {\n    const fn = \"onEnter\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    if (!this.hasOp(opName)) throw Error(`${fn}: node '${opName}' does not exist`);\n    if (!this.subs.has(opName)) this.subs.set(opName, /* @__PURE__ */ new Set());\n    this.subs.get(opName).add(subf);\n  }\n  unsubscribe(name, subf) {\n    const fn = \"onEnter\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(name);\n    if (!this.hasOp(name)) throw Error(`${fn}: node '${name}' does not exist`);\n    const subs = this.subs.get(name);\n    if (subs.has(subf)) subs.delete(subf);\n  }\n  _update() {\n    const fn = \"_update\";\n    m_ValidateActiveSeq(this);\n    this.lastOp = this.currentOp;\n    this.currentOp = this.ops[this.opIndex];\n  }\n  _notifyChange() {\n    const fn = \"_notifyChange\";\n    m_ValidateActiveSeq(this);\n    const subs = this.subs.get(this.currentOp._opName);\n    if (subs) subs.forEach((subf) => subf(this.currentOp, this.lastOp, this));\n  }\n  /* --- node utilities --- */\n  hasOp(opName) {\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    return this.ops.some((op) => op._opName === opName);\n  }\n  matchOp(opName) {\n    const fn = \"matchOp\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    if (!this.hasOp(opName)) throw Error(`${fn}: node '${opName}' does not exist`);\n    return opName === this.ops[this.opIndex]._opName;\n  }\n  /** remove all nodes and subscribers */\n  dispose() {\n    _OpSequencer.DeleteSequencer(this.seqName);\n  }\n  /* --- static utilities --- */\n  static GetSequencer(seqName) {\n    m_ValidateSeqName(seqName);\n    return OPSEQS.get(seqName);\n  }\n  static DeleteSequencer(seqName) {\n    const seq = _OpSequencer.GetSequencer(seqName);\n    seq.opsMap.clear();\n    seq.subs.forEach((subs) => subs.clear());\n    seq.ops.length = 0;\n    seq._disposed = true;\n    OPSEQS.delete(seqName);\n  }\n};\nvar class_op_seq_default = OpSequencer;\n\n// _ur/common/class-state-mgr.ts\nvar VM_STATE = {};\nvar GROUPS = /* @__PURE__ */ new Map();\nvar USED_PROPS = /* @__PURE__ */ new Map();\nvar StateMgr = class _StateMgr {\n  // queued side effects\n  /// CONSTRUCTOR /////////////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  constructor(groupName) {\n    __publicField(this, \"name\");\n    // the name of this state group\n    __publicField(this, \"init\");\n    // true if _initializeState has been called\n    __publicField(this, \"subs\");\n    __publicField(this, \"queue\");\n    // queued state changes\n    __publicField(this, \"taps\");\n    // queued state interceptor hooks\n    __publicField(this, \"effects\");\n    if (typeof groupName !== \"string\") throw Error(\"groupName must be a string\");\n    groupName = groupName.trim().toUpperCase();\n    if (GROUPS.has(groupName)) {\n      console.warn(\n        `(not an error) '${groupName}' construction duplicate, returning existing instance`\n      );\n      return GROUPS.get(groupName);\n    }\n    this.name = groupName;\n    this.init = false;\n    this.subs = /* @__PURE__ */ new Set();\n    this.queue = [];\n    this.taps = [];\n    this.effects = [];\n    VM_STATE[this.name] = {};\n    this.state = this.state.bind(this);\n    this.sendState = this.sendState.bind(this);\n    this.subscribeState = this.subscribeState.bind(this);\n    this.unsubscribeState = this.unsubscribeState.bind(this);\n    this.queueEffect = this.queueEffect.bind(this);\n    this._initializeState = this._initializeState.bind(this);\n    this._setState = this._setState.bind(this);\n    this._insertStateEvent = this._insertStateEvent.bind(this);\n    this._interceptState = this._interceptState.bind(this);\n    this._isValidState = this._isValidState.bind(this);\n    this._mergeState = this._mergeState.bind(this);\n    this._notifySubs = this._notifySubs.bind(this);\n    this._enqueue = this._enqueue.bind(this);\n    this._dequeue = this._dequeue.bind(this);\n    this._doEffect = this._doEffect.bind(this);\n    GROUPS.set(this.name, this);\n  }\n  /// MAIN CLASS METHODS //////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Return a COPY of the current clonedEvent */\n  state(key) {\n    const state = this._derefProps({ ...VM_STATE[this.name] });\n    if (typeof key === \"string\" && key.length > 0) return state[key];\n    return state;\n  }\n  /** Handle a clonedEvent update from a subscribing module. The incoming\n   *  vmstateEvent is checked against the master state object to ensure it\n   *  contains valid keys. Any filter functions are allowed to mutate a copy of\n   *  the incoming state event.\n   *  @param {object} vmStateEvent - object with group-specific props\n   */\n  sendState(vmStateEvent, callback) {\n    if (this._isValidState(vmStateEvent)) {\n      const clonedEvent = this._cloneStateObject(vmStateEvent);\n      this.taps.forEach((tap) => tap(clonedEvent));\n      const action = { stateEvent: clonedEvent, callback };\n      this._enqueue(action);\n    } else throw Error(\"SendState: invalid vmState update received, got:\");\n  }\n  /** Subscribe to state. The subscriber function looks like:\n   *  ( vmStateEvent, currentState ) => void\n   */\n  subscribeState(subFunc) {\n    if (typeof subFunc !== \"function\") throw Error(\"subscriber must be function\");\n    if (this.subs.has(subFunc)) console.warn(\"duplicate subscriber function\");\n    this.subs.add(subFunc);\n  }\n  /** Unsubscribe state */\n  unsubscribeState(subFunc) {\n    if (!this.subs.delete(subFunc))\n      console.warn(\"function not subscribed for\", this.name);\n  }\n  /** When executing a side effect from a component, use this method to\n   *  hold it until after all state updates have completed, so the DOM\n   *  is stable\n   */\n  queueEffect(effectFunc) {\n    if (typeof effectFunc !== \"function\") throw Error(\"effect must be a function\");\n    this.effects.push(effectFunc);\n    this._doEffect();\n  }\n  /// CLASS HELPER METHODS ////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Set the state object directly. used to initialize the state from within\n   *  an appcore module. skips state validation because the VM_STATE entry\n   *  is an empty object\n   */\n  _initializeState(stateObj) {\n    if (this.init)\n      throw Error(`_initializeState: store '${this.name}' already initialized`);\n    Object.keys(stateObj).forEach((k) => {\n      if (k.toLowerCase() !== k)\n        throw Error(`_initializeState: props must be lowercase, not '${k}'`);\n      if (stateObj[k] === void 0)\n        throw Error(\n          `_initializeState: prop '${k}' value can't be undefined (use null instead)`\n        );\n    });\n    if (VM_STATE[this.name]) {\n      Object.keys(stateObj).forEach((k) => {\n        if (k === \"_group\") return;\n        const assTo = USED_PROPS.get(k);\n        if (assTo !== void 0) throw Error(`${k} already assigned to ${assTo}`);\n        USED_PROPS.set(k, this.name);\n      });\n      VM_STATE[this.name] = stateObj;\n      this.init = true;\n    } else throw Error(`${this.name} does't exist in VM_STATE`);\n  }\n  /** In some cases, we want to update state but not trigger subscribers\n   *  related to it. Alias for _mergeState()\n   */\n  _setState(vmState) {\n    this._mergeState(vmState);\n  }\n  /** When SendState() is invoked, give the instance manager a change to\n   *  inspect the incoming state and do a side-effect and/or a filter.\n   *  They will run in order of interceptor registration\n   *  @param {function} tapFunc - receive stateEvent to mutate or act-on\n   */\n  _interceptState(tapFunc) {\n    if (typeof tapFunc !== \"function\") throw Error(`'${tapFunc}' is not a function`);\n    this.taps.push(tapFunc);\n  }\n  /** Allow synthesis of a state event by adding to queue without\n   *  immediately executing it. For use by _interceptState only.\n   *  Creates an action { stateObj, callback }\n   */\n  _insertStateEvent(stateEvent, callback) {\n    this._enqueue({ stateEvent, callback });\n  }\n  /** Return true if the event object conforms to expectations (see below) */\n  _isValidState(stateObj) {\n    const curState = VM_STATE[this.name];\n    let keysOk = true;\n    Object.keys(stateObj).forEach((k) => {\n      const keyTest = keysOk && curState[k] !== void 0;\n      if (keyTest === false) console.warn(`isValidState: '${k}' not a valid key`);\n      keysOk = keysOk && keyTest;\n    });\n    return keysOk;\n  }\n  /** Scan the object properties for arrays, and mutate with a new array.\n   *  In the case of an array containing references, the references will still\n   *  be the same but the array itself will be different\n   */\n  _derefProps(stateObj) {\n    Object.keys(stateObj).forEach((k) => {\n      if (Array.isArray(stateObj[k])) stateObj[k] = [...stateObj[k]];\n    });\n    return stateObj;\n  }\n  /** Utility method to clone state event. It handles array cloning as well but\n   *  is otherwise a shallow clone\n   */\n  _cloneStateObject(stateObj) {\n    const clone = this._derefProps({ ...stateObj });\n    return clone;\n  }\n  /** Take a clonedEvent event object and update the VM_STATE entry with\n   *  its property values. This creates an entirely new state object\n   */\n  _mergeState(stateObj) {\n    if (!this._isValidState(stateObj)) return void 0;\n    const newState = this._derefProps({\n      ...VM_STATE[this.name],\n      ...stateObj\n    });\n    VM_STATE[this.name] = newState;\n    return newState;\n  }\n  /** Forward the event to everyone. The vmStateEvent object contains\n   *  properties that changed only, appending a 'stateGroup' identifier\n   *  that tells you who sent it. Sends a read-only copy.\n   */\n  _notifySubs(stateObj) {\n    setTimeout(() => {\n      const subs = [...this.subs.values()];\n      stateObj.stateGroup = this.name;\n      const currentState = this._derefProps({ ...VM_STATE[this.name] });\n      subs.forEach((sub) => sub(stateObj, currentState));\n    });\n  }\n  /** Placeholder queueing system that doesn't do much now.\n   *  An action is { vmStateEvent, callback }\n   */\n  _enqueue(action) {\n    const { stateEvent, callback } = action;\n    if (!this._isValidState(stateEvent)) {\n      console.warn(\"bad vmStateEvent\", stateEvent);\n      return;\n    }\n    if (callback && typeof callback !== \"function\") {\n      console.warn(\"call must be function, not\", typeof callback, callback);\n      return;\n    }\n    this.queue.push(action);\n    this._dequeue();\n  }\n  /** Placeholder dequeing system that doesn't do much now.\n   *  An action is { vmStateEvent, callback }\n   */\n  _dequeue() {\n    const callbacks = [];\n    let action = this.queue.shift();\n    while (action !== void 0) {\n      const { vmStateEvent, callback } = action;\n      this._mergeState(vmStateEvent);\n      this._notifySubs(vmStateEvent);\n      if (typeof callback === \"function\") callbacks.push(callback);\n      action = this.queue.shift();\n    }\n    callbacks.forEach((f) => f());\n    this._doEffect();\n  }\n  /** execute effect functions that have been queued, generally if there\n   *  are no pending state changes\n   */\n  _doEffect() {\n    if (this.queue.length > 0) return;\n    setTimeout(() => {\n      let effect = this.effects.shift();\n      while (effect !== void 0) {\n        effect();\n        effect = this.effects.shift();\n      }\n    });\n  }\n  /// STATIC METHODS //////////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Return a state manager instance if it exists, undefined if not. Throws\n   *  errors if there are issues with the name */\n  static GetStateManager(groupName) {\n    if (typeof groupName !== \"string\") throw Error(`${groupName} is not a string`);\n    const bucket = groupName.trim().toUpperCase();\n    if (bucket !== groupName)\n      throw Error(`groupNames should be all uppercase, not ${bucket}`);\n    return GROUPS[bucket];\n  }\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** return a locked copy of the state of a particular named state group.\n   *  Unlike GetStateManager, this returns just the data object.\n   */\n  static GetStateData(groupName) {\n    if (typeof groupName !== \"string\") throw Error(`${groupName} is not a string`);\n    const bucket = groupName.trim().toUpperCase();\n    if (bucket !== groupName)\n      throw Error(`groupNames should be all uppercase, not ${bucket}`);\n    const state = VM_STATE[bucket];\n    if (!state) throw Error(`stateGroup ${bucket} is not defined`);\n    const readOnlyState = { ...state };\n    for (const prop of Object.keys(readOnlyState)) {\n      Object.defineProperty(readOnlyState, prop, {\n        writable: false\n      });\n    }\n    return readOnlyState;\n  }\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** return a Stage Manager instance. This just hides the new operator that\n   *  purposefully always returns an instance of an existing group if it\n   *  already exists\n   */\n  static GetInstance(groupName) {\n    return new _StateMgr(groupName);\n  }\n};\nvar class_state_mgr_default = StateMgr;\n\n// _ur/browser-client/urnet-browser.ts\nvar urnet_browser_exports = {};\n__export(urnet_browser_exports, {\n  Connect: () => Connect,\n  Disconnect: () => Disconnect,\n  EX_Start: () => EX_Start,\n  RegisterMessages: () => RegisterMessages\n});\n\n// _ur/common/types-urnet.ts\nvar VALID_MSG_CHANNELS = [\"NET\", \"SRV\", \"LOCAL\", \"\"];\nvar VALID_PKT_TYPES = [\n  \"ping\",\n  \"signal\",\n  \"send\",\n  \"call\",\n  \"_auth\",\n  // special packet\n  \"_reg\",\n  // special packet\n  \"_decl\"\n  // special packet\n];\nvar SKIP_SELF_PKT_TYPES = [\"call\", \"send\"];\nvar VALID_ADDR_PREFIX = [\"???\", \"UR_\", \"WSS\", \"UDS\", \"MQT\", \"SRV\"];\nvar UADDR_DIGITS = 3;\nvar USED_ADDRS = /* @__PURE__ */ new Set();\nvar zeroPad = `0`.padStart(UADDR_DIGITS, \"0\");\nvar UADDR_NONE = `???${zeroPad}`;\nfunction IsValidType(msg_type) {\n  return VALID_PKT_TYPES.includes(msg_type);\n}\nfunction SkipOriginType(msg_type) {\n  return SKIP_SELF_PKT_TYPES.includes(msg_type);\n}\nfunction IsValidChannel(msg_chan) {\n  return VALID_MSG_CHANNELS.includes(msg_chan);\n}\nfunction IsValidAddress(addr) {\n  if (typeof addr !== \"string\") return false;\n  let prelen = 0;\n  if (!VALID_ADDR_PREFIX.some((pre) => {\n    prelen = pre.length;\n    return addr.startsWith(pre);\n  }))\n    return false;\n  const num = parseInt(addr.slice(prelen));\n  if (isNaN(num)) return false;\n  return true;\n}\nfunction IsValidMessage(msg) {\n  try {\n    return DecodeMessage(msg);\n  } catch (err) {\n    console.log(err.message);\n    console.log(err.stack.split(\"\\n\").slice(1).join(\"\\n\").trim());\n    return void 0;\n  }\n}\nvar ADDR_MAX_ID = 0;\nfunction AllocateAddress(opt) {\n  const fn = \"AllocateAddress\";\n  let addr = opt == null ? void 0 : opt.addr;\n  let pre = (opt == null ? void 0 : opt.prefix) || \"UA\";\n  if (addr === void 0) {\n    let id = ++ADDR_MAX_ID;\n    let padId = `${id}`.padStart(UADDR_DIGITS, \"0\");\n    addr = `${pre}${padId}`;\n  } else if (USED_ADDRS.has(addr)) {\n    throw Error(`${fn} - address ${addr} already allocated`);\n  }\n  USED_ADDRS.add(addr);\n  return addr;\n}\nfunction DecodeMessage(msg) {\n  if (typeof msg !== \"string\") throw Error(`message must be string: ${msg}`);\n  if (msg !== msg.toUpperCase()) throw Error(`message must be uppercase: ${msg}`);\n  const bits = msg.split(\":\");\n  if (bits.length === 0) throw Error(`invalid empty message`);\n  if (bits.length > 2) throw Error(`invalid channel:message format ${msg}`);\n  let [chan, name] = bits;\n  if (bits.length === 1) {\n    name = chan;\n    chan = \"LOCAL\";\n  }\n  if (chan === \"\") chan = \"LOCAL\";\n  if (!IsValidChannel(chan))\n    throw Error(`prefix must be ${VALID_MSG_CHANNELS.join(\" \").trim()} not ${chan}`);\n  return [chan, name];\n}\nfunction NormalizeMessage(msg) {\n  let [chan, name] = DecodeMessage(msg);\n  if (chan === \"LOCAL\") chan = \"\";\n  return `${chan}:${name}`;\n}\nfunction NormalizeData(data) {\n  if (Array.isArray(data) && data.length == 1) return data[0];\n  return data;\n}\nfunction IsLocalMessage(msg) {\n  const [chan] = DecodeMessage(msg);\n  return chan === \"LOCAL\";\n}\nfunction IsNetMessage(msg) {\n  const [chan] = DecodeMessage(msg);\n  return chan === \"NET\" || chan === \"SRV\";\n}\nfunction GetPacketHashString(pkt) {\n  return `${pkt.src_addr}:${pkt.id}`;\n}\n\n// _ur/common/class-urnet-packet.ts\nvar PR = typeof process !== \"undefined\" ? \"Packet\".padEnd(13) : \"Packet:\";\nvar LOG = (...args) => console.log(PR, ...args);\nvar NetPacket = class {\n  // returned error message\n  constructor(msg, data) {\n    __publicField(this, \"id\");\n    // network-wide unique id for this packet\n    __publicField(this, \"msg_type\");\n    // ping, signal, send, call\n    __publicField(this, \"msg\");\n    // name of the URNET message\n    __publicField(this, \"data\");\n    // payload of the URNET message\n    __publicField(this, \"auth\");\n    // authentication token\n    __publicField(this, \"src_addr\");\n    // URNET address of the sender\n    __publicField(this, \"hop_seq\");\n    // URNET addresses that have seen this packet\n    __publicField(this, \"hop_log\");\n    // log of debug messages by hop\n    __publicField(this, \"hop_dir\");\n    // direction of the packet 'req' or 'res'\n    __publicField(this, \"hop_rsvp\");\n    // whether the packet is a response to a request\n    __publicField(this, \"err\");\n    this.id = void 0;\n    this.src_addr = void 0;\n    this.hop_rsvp = false;\n    this.hop_seq = [];\n    this.hop_log = [];\n    this.auth = void 0;\n    this.err = void 0;\n    if (data !== void 0) this.data = data;\n    if (typeof msg === \"string\") {\n      if (!IsValidMessage(msg)) throw Error(`invalid msg format: ${msg}`);\n      this.msg = msg;\n    }\n  }\n  /** after creating a new packet, use setMeta() to assign id and envelope\n   *  meta used for routing and return packets\n   */\n  setMeta(msg_type, opt) {\n    if (!IsValidType(msg_type)) throw Error(`invalid msg_type: ${msg_type}`);\n    this.msg_type = msg_type;\n    this.hop_dir = (opt == null ? void 0 : opt.dir) || \"req\";\n    this.hop_rsvp = (opt == null ? void 0 : opt.rsvp) || false;\n  }\n  /** add hop to the hop sequence */\n  addHop(hop) {\n    if (!IsValidAddress(hop)) throw Error(`invalid hop: ${hop}`);\n    this.hop_seq.push(hop);\n  }\n  /** utility setters w/ checks - - - - - - - - - - - - - - - - - - - - - - **/\n  /** manually set the source address, with check */\n  setSrcAddr(s_addr) {\n    if (!IsValidAddress(s_addr)) throw Error(`invalid src_addr: ${s_addr}`);\n    if (this.hop_seq.length > 0 && this.hop_seq[0] !== s_addr)\n      throw Error(`src_addr ${s_addr} != ${this.hop_seq[0]}`);\n    this.src_addr = s_addr;\n    return this;\n  }\n  /** manually set direction */\n  setDir(dir) {\n    if (dir !== \"req\" && dir !== \"res\") throw Error(`invalid dir: ${dir}`);\n    this.hop_dir = dir;\n    return this;\n  }\n  /** set the authorization token */\n  setAuth(auth) {\n    if (typeof auth !== \"string\") {\n      LOG(\"setAuth: invalid auth\", auth);\n      throw Error(`invalid auth: ${auth}`);\n    }\n    this.auth = auth;\n    return this;\n  }\n  /** set message and data */\n  setMsgData(msg, data) {\n    this.setMsg(msg);\n    this.setData(data);\n    return this;\n  }\n  /** set message */\n  setMsg(msg) {\n    this.msg = msg;\n    return this;\n  }\n  /** set data */\n  setData(data) {\n    this.data = data;\n    return this;\n  }\n  /** merge data */\n  mergeData(data) {\n    this.data = { ...this.data, ...data };\n    return this;\n  }\n  /** packet reconstruction - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** make a packet from existing JSON */\n  setFromJSON(json) {\n    if (typeof json !== \"string\")\n      throw Error(`invalid json: ${json}, is ${typeof json}`);\n    return this.deserialize(json);\n  }\n  /** make a packet from existing object */\n  setFromObject(pktObj) {\n    const fn = \"setFromObject\";\n    if (typeof pktObj !== \"object\")\n      throw Error(`invalid pktObj: ${pktObj}, is ${typeof pktObj}`);\n    this.id = pktObj.id;\n    this.msg = pktObj.msg;\n    if (pktObj.data === void 0)\n      LOG(fn, `... pktObj${pktObj.id} .data is undefined`);\n    this.data = pktObj.data;\n    this.src_addr = pktObj.src_addr;\n    this.hop_log = pktObj.hop_log;\n    this.msg_type = pktObj.msg_type;\n    this.hop_seq = pktObj.hop_seq;\n    this.hop_dir = pktObj.hop_dir;\n    this.hop_rsvp = pktObj.hop_rsvp;\n    this.err = pktObj.err;\n    this.auth = pktObj.auth;\n    return this;\n  }\n  /** packet transport  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** rsvp required? */\n  hasRsvp() {\n    return this.hop_rsvp;\n  }\n  lastHop() {\n    return this.hop_seq[this.hop_seq.length - 1];\n  }\n  hasAuth() {\n    return this.auth !== void 0;\n  }\n  /** types that begin with _ are protocol messages that bypass dispatchPacket() */\n  isSpecialPkt() {\n    return this.msg_type.startsWith(\"_\");\n  }\n  /** authorization packets are the first packet sent on a client connection to\n   *  the message gateway server. They must not have a src_addr aassigned, using\n   *  the special UADDR_NONE value instead.\n   */\n  isBadAuthPkt() {\n    let error = \"\";\n    let a = this.msg_type === \"_auth\";\n    let b = this.msg === \"SRV:AUTH\";\n    let c = this.src_addr === UADDR_NONE;\n    if (!a) error += `msg_type ${this.msg_type} not _auth. `;\n    if (!b) error += `msg ${this.msg} not SRV:AUTH. `;\n    if (!c) error += `src_addr ${this.src_addr} not ${UADDR_NONE} `;\n    if (error.length > 0) return `isBadAuthPkt: ${error}`;\n    return void 0;\n  }\n  /** registration packets are sent on a client connection after\n   *  authentication. They must have a src_addr assigned, which was returned\n   *  by the server in the response to the auth packet, and this must match\n   *  the server's stored uaddr for the client connection.\n   */\n  isBadRegPkt(socket) {\n    let error = \"\";\n    let a = this.msg_type === \"_reg\";\n    let b = this.msg === \"SRV:REG\";\n    let c = this.src_addr === socket.uaddr;\n    if (!a) error += `msg_type ${this.msg_type} not _reg. `;\n    if (!b) error += `msg ${this.msg} not SRV:REG. `;\n    if (!c) error += `src_addr ${this.src_addr} not ${socket.uaddr}. `;\n    if (error.length > 0) return `isBadRegPkt: ${error}`;\n    return void 0;\n  }\n  authenticate(socket) {\n    const { msg, src_addr, hop_dir, hop_seq } = this;\n    if (!this.isResponse()) LOG(PR, `would auth ${src_addr} '${msg}'`);\n    return true;\n  }\n  isRequest() {\n    return this.hop_dir === \"req\";\n  }\n  isResponse() {\n    return this.hop_dir === \"res\";\n  }\n  /** serialization - - - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  serialize() {\n    return JSON.stringify(this);\n  }\n  deserialize(data) {\n    try {\n      let obj = JSON.parse(data);\n      return this.setFromObject(obj);\n    } catch (err) {\n      LOG(\"NetPacket.deserialize failed\", data);\n    }\n  }\n  /** information utilities - - - - - - - - - - - - - - - - - - - - - - - - **/\n  isValidType(type) {\n    return IsValidType(type);\n  }\n  isValidMessage(msg) {\n    return IsValidMessage(msg) !== void 0;\n  }\n  decodeMessage(msg) {\n    return DecodeMessage(msg);\n  }\n  /** debugging - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** add error string to packet error */\n  error(msg) {\n    if (!this.err) this.err = \"\";\n    this.err += msg;\n    return msg;\n  }\n  /** manually add a transport-related message eto the hog log. this is not\n   *  the same as hop_seq which is used to track the routing of the packet.\n   */\n  hopLog(msg) {\n    const info = `${this.id} ${this.hop_dir}`;\n    this.hop_log.push(`${info}: ${msg}`);\n    return msg;\n  }\n};\nvar class_urnet_packet_default = NetPacket;\n\n// _ur/common/class-urnet-endpoint.ts\nvar PR2 = typeof process !== \"undefined\" ? \"EndPoint\".padEnd(13) : \"EndPoint\".padEnd(11);\nvar LOG2 = console.log.bind(console);\nvar AGE_INTERVAL = 1e3;\nvar AGE_MAX = 60 * 30;\nvar NetEndpoint = class {\n  // client registration status\n  constructor() {\n    __publicField(this, \"handled_msgs\");\n    // msg->handlers[]\n    //\n    __publicField(this, \"uaddr\");\n    // the address for this endpoint\n    __publicField(this, \"client_socks\");\n    // uaddr->I_NetSocket\n    __publicField(this, \"remoted_msgs\");\n    // msg->uaddr[]\n    __publicField(this, \"transactions\");\n    // hash->resolver\n    //\n    __publicField(this, \"cli_counter\");\n    // counter for generating unique uaddr\n    __publicField(this, \"pkt_counter\");\n    // counter for generating packet ids\n    //\n    __publicField(this, \"cli_gateway\");\n    // gateway to server\n    __publicField(this, \"cli_sck_timer\");\n    // timer for checking socket age\n    __publicField(this, \"cli_ident\");\n    // client credentials to request authentication\n    __publicField(this, \"cli_auth\");\n    // client access token for\n    __publicField(this, \"cli_reg\");\n    this.uaddr = void 0;\n    this.cli_ident = void 0;\n    this.cli_auth = void 0;\n    this.cli_reg = void 0;\n    this.cli_gateway = void 0;\n    this.client_socks = void 0;\n    this.remoted_msgs = void 0;\n    this.handled_msgs = /* @__PURE__ */ new Map();\n    this.transactions = /* @__PURE__ */ new Map();\n    this.pkt_counter = 0;\n    this.cli_counter = 0;\n    this.cli_sck_timer = null;\n  }\n  /** API: initialize this endpoint's client server, providing a hardcoded\n   *  server UADDR that is distinct from those used by client pools\n   */\n  configAsServer(srv_addr) {\n    const fn = \"configAsServer:\";\n    if (!IsValidAddress(srv_addr)) throw Error(`${fn} invalid srv_addr ${srv_addr}`);\n    if (this.uaddr && this.uaddr !== srv_addr) {\n      let err = `${fn} uaddr ${this.uaddr} already set.`;\n      throw Error(err);\n    }\n    this.uaddr = srv_addr;\n    if (this.client_socks !== void 0)\n      LOG2(PR2, this.uaddr, `already configured`, [...this.client_socks.keys()]);\n    this.client_socks = /* @__PURE__ */ new Map();\n    if (this.remoted_msgs !== void 0)\n      LOG2(PR2, this.uaddr, `already configured`, [...this.remoted_msgs.keys()]);\n    this.remoted_msgs = /* @__PURE__ */ new Map();\n    this.addMessageHandler(\"SRV:REFLECT\", (data) => {\n      data.info = `built-in service`;\n      return data;\n    });\n  }\n  /** API: Server data event handler for incoming data from a client connection.\n   *  This is the mirror to _ingestServerPacket() function used by client endpoints.\n   *  This is the entry point for incoming data from clients */\n  _ingestClientPacket(jsonData, socket) {\n    let pkt = this.newPacket().deserialize(jsonData);\n    let retPkt;\n    retPkt = this._handleAuthRequest(pkt, socket);\n    if (retPkt) return retPkt;\n    retPkt = this._handleRegRequest(pkt, socket);\n    if (retPkt) return retPkt;\n    retPkt = this._handleDeclRequest(pkt, socket);\n    if (retPkt) return retPkt;\n    this.dispatchPacket(pkt);\n  }\n  /** API: when a client connects to this endpoint, register it as a socket and\n   *  allocate a uaddr for it */\n  addClient(socket) {\n    const fn = \"addClient:\";\n    if (typeof socket !== \"object\") throw Error(`${fn} invalid socket`);\n    if (socket.uaddr !== void 0) throw Error(`${fn} socket already added`);\n    const new_uaddr = AllocateAddress({ prefix: \"UR_\" });\n    socket.uaddr = new_uaddr;\n    socket.age = 0;\n    socket.auth = void 0;\n    socket.msglist = void 0;\n    this.client_socks.set(new_uaddr, socket);\n    return new_uaddr;\n  }\n  /** API: when a client disconnects from this endpoint, delete its socket and\n   *  remove all message forwarding */\n  removeClient(uaddr_obj) {\n    const fn = \"removeClient:\";\n    let uaddr = typeof uaddr_obj === \"string\" ? uaddr_obj : uaddr_obj.uaddr;\n    if (typeof uaddr !== \"string\") {\n      LOG2(PR2, `${fn} invalid uaddr ${typeof uaddr}`);\n      return void 0;\n    }\n    if (!this.client_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    this._deleteRemoteMessagesForAddress(uaddr);\n    this.client_socks.delete(uaddr);\n    return uaddr;\n  }\n  /** API: given a uaddr, return the socket */\n  getClient(uaddr) {\n    const fn = \"getClient:\";\n    if (this.client_socks === void 0) return void 0;\n    return this.client_socks.get(uaddr);\n  }\n  /** API: start a timer to check for dead sockets */\n  enableClientAging(activate) {\n    const fn = \"enableClientAging:\";\n    if (activate) {\n      if (this.cli_sck_timer) clearInterval(this.cli_sck_timer);\n      this.cli_sck_timer = setInterval(() => {\n        this.client_socks.forEach((socket, uaddr) => {\n          socket.age += AGE_INTERVAL;\n          if (socket.age > AGE_MAX) {\n            LOG2(PR2, this.uaddr, `socket ${uaddr} expired`);\n          }\n        });\n      }, AGE_INTERVAL);\n      return;\n    }\n    if (this.cli_sck_timer) clearInterval(this.cli_sck_timer);\n    this.cli_sck_timer = null;\n    LOG2(PR2, this.uaddr, `timer stopped`);\n  }\n  /** support: handle auth packet if the session.auth is not defined */\n  _handleAuthRequest(pkt, socket) {\n    if (!socket.authenticated()) {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.uaddr);\n      const error = pkt.isBadAuthPkt();\n      if (error) {\n        console.error(PR2, error);\n        pkt.data = { error };\n        return pkt;\n      }\n      const { identity, secret } = pkt.data;\n      if (identity) {\n        socket.auth = identity;\n        pkt.data = { uaddr: socket.uaddr, cli_auth: \"ServerProvidedAuthToken\" };\n      } else {\n        pkt.data = { error: \"invalid identity\" };\n      }\n      return pkt;\n    }\n    return void 0;\n  }\n  /** support: handle registration packet */\n  _handleRegRequest(pkt, socket) {\n    if (!pkt.isBadRegPkt(socket)) {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.uaddr);\n      if (pkt.msg !== \"SRV:REG\") {\n        pkt.data = { error: `invalid reg packet ${pkt.msg}` };\n        return pkt;\n      }\n      if (pkt.src_addr !== socket.uaddr) {\n        LOG2(PR2, \"src address mismatch\", pkt.src_addr, \"!= sock\", socket.uaddr);\n        pkt.data = { error: \"address mismatch\" };\n        return pkt;\n      }\n      const { name, type } = pkt.data;\n      if (name) {\n        const { uaddr } = socket;\n        pkt.data = { ok: true, status: `registered name:${name} type:${type}` };\n        return pkt;\n      }\n      pkt.data = { error: \"registration failed\" };\n      return pkt;\n    }\n    return void 0;\n  }\n  /** support: handle client dynamic definitions */\n  _handleDeclRequest(pkt, socket) {\n    if (pkt.msg_type === \"_decl\") {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.uaddr);\n      if (pkt.msg !== \"SRV:DEF\") {\n        console.log(\"invalid def packet\", pkt.msg);\n        pkt.data = { error: `invalid def packet ${pkt.msg}` };\n        return pkt;\n      }\n      pkt.data.status = [];\n      const { msg_list } = pkt.data;\n      const { uaddr } = socket;\n      if (Array.isArray(msg_list)) {\n        this.registerRemoteMessagesToAddress(uaddr, msg_list);\n        pkt.data.status.push(`registered ${msg_list.length} messages`);\n      }\n      if (pkt.data.status.length === 0) {\n        pkt.data = { error: \"no definitions\" };\n        return pkt;\n      }\n    }\n    return void 0;\n  }\n  /** client connection handshaking - - - - - - - - - - - - - - - - - - - - **/\n  /** API: client endpoints need to have an \"address\" assigned to them,\n   *  otherwise the endpoint will not work */\n  async connectAsClient(gateway, auth) {\n    const fn = \"connectAsClient:\";\n    if (gateway && typeof gateway.send === \"function\") {\n      this.cli_gateway = gateway;\n    } else throw Error(`${fn} invalid gateway`);\n    if (auth) {\n      const pkt = this.newAuthPacket(auth);\n      const { msg } = pkt;\n      let authData = await this._queueTransaction(pkt, gateway);\n      const { uaddr, cli_auth, error } = authData;\n      if (error) {\n        LOG2(PR2, `${fn} error:`, error);\n        return false;\n      }\n      if (!IsValidAddress(uaddr)) throw Error(`${fn} invalid uaddr ${uaddr}`);\n      this.uaddr = uaddr;\n      if (cli_auth === void 0) throw Error(`${fn} invalid cli_auth`);\n      this.cli_auth = cli_auth;\n      LOG2(PR2, \"AUTHENTICATED\", uaddr, cli_auth);\n      this.cli_auth = cli_auth;\n      return authData;\n    }\n    throw Error(`${fn} arg must be identity`);\n  }\n  /** API: Client data event handler for incoming data from the gateway. This is\n   *  the mirror to _ingestClientPacket() function that is used by servers. This\n   *  is entry point for incoming data from server\n   */\n  _ingestServerPacket(jsonData, socket) {\n    const fn = \"_ingestServerPacket:\";\n    const pkt = this.newPacket().deserialize(jsonData);\n    if (this.cli_gateway) {\n      if (this._handleAuthResponse(pkt)) return;\n      if (this._handleRegResponse(pkt)) return;\n      if (this._handleDeclResponse(pkt)) return;\n    }\n    this.dispatchPacket(pkt);\n  }\n  /** API: register client with client endpoint info */\n  async declareClientProperties(info) {\n    const fn = \"declareClientProperties:\";\n    if (!this.cli_gateway) throw Error(`${fn} no gateway`);\n    const pkt = this.newRegPacket();\n    pkt.data = { ...info };\n    let regData = await this._queueTransaction(pkt, this.cli_gateway);\n    const { ok, status, error } = regData;\n    if (error) {\n      LOG2(PR2, `${fn} error:`, error);\n      return regData;\n    }\n    if (ok) {\n      LOG2(PR2, \"REGISTERED\", status);\n      this.cli_reg = info;\n      return regData;\n    }\n    throw Error(`${fn} unexpected response`, regData);\n  }\n  /** API: declare client messages */\n  async declareClientMessages() {\n    const fn = \"declareClientMessages:\";\n    const msg_list = this.getNetMessageNames();\n    const response = await this._declareClientServices({ msg_list });\n    const { msg_list: rmsg_list, error } = response;\n    if (error) {\n      LOG2(PR2, `${fn} error:`, error);\n    } else {\n      LOG2(PR2, `DECLARED ${rmsg_list.length} messages`);\n      rmsg_list.forEach((msg) => LOG2(PR2, `  '${msg}'`));\n    }\n    return response;\n  }\n  /** support: handle authentication response packet directly rather than through\n   *  the netcall interface in dispatchPacket() */\n  _handleAuthResponse(pkt) {\n    const fn = \"_handleAuthResponse:\";\n    if (pkt.msg_type !== \"_auth\") return false;\n    if (pkt.hop_dir !== \"res\") return false;\n    this.resolveTransaction(pkt);\n    return true;\n  }\n  /** support: handle registration response packet directly rather than through\n   *  the netcall interface in dispatchPacket() */\n  _handleRegResponse(pkt) {\n    const fn = \"_handleRegResponse:\";\n    if (pkt.msg_type !== \"_reg\") return false;\n    if (pkt.hop_dir !== \"res\") return false;\n    if (pkt.src_addr !== this.uaddr) throw Error(`${fn} misaddressed packet???`);\n    this.resolveTransaction(pkt);\n    return true;\n  }\n  /** support: handle declaration packet */\n  _handleDeclResponse(pkt) {\n    const fn = \"_handleDeclResponse:\";\n    if (pkt.msg_type !== \"_decl\") return false;\n    if (pkt.hop_dir !== \"res\") return false;\n    if (pkt.src_addr !== this.uaddr) throw Error(`${fn} misaddressed packet???`);\n    this.resolveTransaction(pkt);\n    return true;\n  }\n  /** message declaration and invocation - - - - - - - - - - - - - - - - - -**/\n  /** API: declare a message handler for a given message */\n  addMessageHandler(msg, handler) {\n    const fn = \"addMessageHandler:\";\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    if (msg !== msg.toUpperCase()) throw Error(`${fn} msg must be uppercase`);\n    if (typeof handler !== \"function\") throw Error(`${fn} invalid handler`);\n    const key = NormalizeMessage(msg);\n    if (!this.handled_msgs.has(key))\n      this.handled_msgs.set(key, /* @__PURE__ */ new Set());\n    const handler_set = this.handled_msgs.get(key);\n    handler_set.add(handler);\n  }\n  /** API: remove a previously declared message handler for a given message */\n  deleteMessageHandler(msg, handler) {\n    const fn = \"deleteMessageHandler:\";\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    if (typeof handler !== \"function\") throw Error(`${fn} invalid handler`);\n    const key = NormalizeMessage(msg);\n    const handler_set = this.handled_msgs.get(key);\n    if (!handler_set) throw Error(`${fn} unexpected empty set '${key}'`);\n    handler_set.delete(handler);\n  }\n  /** API: call local message registered on this endPoint only */\n  async call(msg, data) {\n    const fn = \"call:\";\n    if (!IsLocalMessage(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getMessageHandlers(msg);\n    const promises = [];\n    handlers.forEach((handler) => {\n      promises.push(\n        new Promise((resolve, reject) => {\n          try {\n            resolve(handler({ ...data }));\n          } catch (err) {\n            reject(err);\n          }\n        })\n      );\n    });\n    if (promises.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    const resData = await Promise.all(promises);\n    return resData;\n  }\n  /** API: send local message registered on this endPoint only, returning no data */\n  async send(msg, data) {\n    const fn = \"send:\";\n    if (!IsLocalMessage(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getMessageHandlers(msg);\n    if (handlers.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    handlers.forEach((handler) => {\n      handler({ ...data });\n    });\n    return Promise.resolve(true);\n  }\n  /** API: signal local message registered on this endPoint only, returning no data.\n   */\n  signal(msg, data) {\n    const fn = \"signal:\";\n    if (!IsLocalMessage(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getMessageHandlers(msg);\n    if (handlers.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    handlers.forEach((handler) => {\n      handler({ ...data });\n    });\n  }\n  /** API: ping local message, return with number of handlers */\n  async ping(msg) {\n    const fn = \"ping:\";\n    if (!IsLocalMessage(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getMessageHandlers(msg);\n    return Promise.resolve(handlers.length);\n  }\n  /** API: call net message, resolves when packet returns from server with data */\n  async netCall(msg, data) {\n    const fn = \"netCall:\";\n    if (!IsNetMessage(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg, data);\n    pkt.setMeta(\"call\", {\n      dir: \"req\",\n      rsvp: true\n    });\n    let resData = await new Promise((resolve, reject) => {\n      const meta = { msg, uaddr: this.uaddr };\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.initialSend(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    return resData;\n  }\n  /** API: send net message, returning promise that will resolve when the server has\n   *  received and processed/forwarded the message */\n  async netSend(msg, data) {\n    const fn = \"netSend:\";\n    if (!IsNetMessage(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg, data);\n    pkt.setMeta(\"send\", {\n      dir: \"req\",\n      rsvp: true\n    });\n    let resData = await new Promise((resolve, reject) => {\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.uaddr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.initialSend(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    return resData;\n  }\n  /** API: signal net message, returning void (not promise)\n   *  used for the idea of 'raising signals' as opposed to 'sending data'. It\n   *  resolves immediately when the signal is sent, and does not check with the\n   *  server  */\n  netSignal(msg, data) {\n    const fn = \"netSignal:\";\n    if (!IsNetMessage(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg, data);\n    pkt.setMeta(\"signal\", {\n      dir: \"req\",\n      rsvp: false\n    });\n    this.initialSend(pkt);\n  }\n  /** API: returns with a list of uaddr from the server which is the uaddr of the\n   *  all clients that have registered for the message */\n  async netPing(msg) {\n    const fn = \"netPing:\";\n    if (!IsNetMessage(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg);\n    pkt.setMeta(\"ping\", {\n      dir: \"req\",\n      rsvp: true\n    });\n    let resData = await new Promise((resolve, reject) => {\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.uaddr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.initialSend(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    return resData;\n  }\n  /** packet utilities  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** declare client attributes is a generic declaration packet that can contain\n   *  any number of attributes that the client wants to declare to the server.\n   *  for example, see declareClientMessages() */\n  async _declareClientServices(def) {\n    const fn = \"_declareClientServices:\";\n    if (!this.cli_gateway) throw Error(`${fn} no gateway`);\n    const pkt = this.newDeclPacket();\n    pkt.data = { ...def };\n    const { msg } = pkt;\n    let declared = await this._queueTransaction(pkt, this.cli_gateway);\n    const { error, status } = declared;\n    if (error) {\n      LOG2(PR2, `${fn} error:`, error);\n      return declared;\n    }\n    if (status) return declared;\n    throw Error(`${fn} unexpected response`, declared);\n  }\n  /** shuts down the gateway to server, forcing close\n   *  Chrome 125.0.6422.77 doesn't seem to send a close frame on reload\n   *  Firefox 126.0 doesn't fire beforeunload\n   */\n  disconnectAsClient() {\n    if (this.cli_gateway === void 0) return;\n    if (typeof this.cli_gateway.close === \"function\") {\n      this.cli_gateway.close();\n    }\n    this.cli_gateway = void 0;\n  }\n  /** endpoint lookup tables - - - - - - - - - - - - - - - - - - - -  - - - **/\n  /** return true if the message is handled anywhere */\n  packetHasHandler(pkt) {\n    const fn = \"messageHasHandler:\";\n    const a = this.getMessageHandlers(pkt.msg).length > 0;\n    const b = this.isServer() && this.getMessageAddresses(pkt.msg).length > 0;\n    return a || b;\n  }\n  /** get list of messages allocated to a uaddr */\n  getMessagesForAddress(uaddr) {\n    const fn = \"getMessagesForAddress:\";\n    if (!this.isServer()) return [];\n    if (typeof uaddr !== \"string\") throw Error(`${fn} invalid uaddr`);\n    if (!this.client_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    const msg_list = [];\n    this.remoted_msgs.forEach((addr_set, msg) => {\n      if (addr_set.has(uaddr)) msg_list.push(msg);\n    });\n    return msg_list;\n  }\n  /** get list of UADDRs that a message is forwarded to */\n  getMessageAddresses(msg) {\n    const fn = \"getMessageAddresses:\";\n    if (!this.isServer()) return [];\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    const key = NormalizeMessage(msg);\n    if (!this.remoted_msgs.has(key))\n      this.remoted_msgs.set(key, /* @__PURE__ */ new Set());\n    const addr_set = this.remoted_msgs.get(key);\n    const addr_list = Array.from(addr_set);\n    return addr_list;\n  }\n  /** return list of local handlers for given message */\n  getMessageHandlers(msg) {\n    const fn = \"getMessageHandlers:\";\n    if (this.handled_msgs === void 0) return [];\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    const key = NormalizeMessage(msg);\n    if (!this.handled_msgs.has(key))\n      this.handled_msgs.set(key, /* @__PURE__ */ new Set());\n    const handler_set = this.handled_msgs.get(key);\n    if (!handler_set) throw Error(`${fn} unexpected empty set '${key}'`);\n    const handler_list = Array.from(handler_set);\n    return handler_list;\n  }\n  /** informational routing information - - - - - - - - - - - - - - - - - - **/\n  /** return handler list for this endpoint */\n  getMessageNames() {\n    const list = [];\n    this.handled_msgs.forEach((handler_set, key) => {\n      list.push(key);\n    });\n    return list;\n  }\n  /** return only net messages */\n  getNetMessageNames() {\n    const list = [];\n    this.handled_msgs.forEach((handler_set, key) => {\n      if (IsNetMessage(key)) list.push(key);\n    });\n    return list;\n  }\n  /** return list of active transactions for this endpoint */\n  getPendingTransactions() {\n    const fn = \"getPendingTransactions:\";\n    const list = [];\n    this.transactions.forEach((transaction, hash) => {\n      const { msg, uaddr } = transaction;\n      list.push({ hash, msg, uaddr });\n    });\n    return list;\n  }\n  /** server endpoints manage list of messages in clients  - - - - -  - - - **/\n  /** register a message handler for a given message to passed uaddr */\n  registerRemoteMessagesToAddress(uaddr, msgList) {\n    const fn = \"registerRemoteMessagesToAddress:\";\n    if (typeof uaddr !== \"string\") throw Error(`${fn} invalid uaddr`);\n    if (!this.client_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    msgList.forEach((msg) => {\n      if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n      if (msg !== msg.toUpperCase()) throw Error(`${fn} msg must be uppercase`);\n      const key = NormalizeMessage(msg);\n      if (!this.remoted_msgs.has(key))\n        this.remoted_msgs.set(key, /* @__PURE__ */ new Set());\n      const msg_set = this.remoted_msgs.get(key);\n      msg_set.add(uaddr);\n    });\n  }\n  /** unregister message handlers for a given message to passed uaddr */\n  _deleteRemoteMessagesForAddress(uaddr) {\n    const fn = \"_deleteRemoteMessagesForAddress:\";\n    if (typeof uaddr !== \"string\") throw Error(`${fn} invalid uaddr`);\n    if (!this.client_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    const removed = [];\n    this.remoted_msgs.forEach((msg_set, key) => {\n      if (msg_set.has(uaddr)) removed.push(key);\n      msg_set.delete(uaddr);\n    });\n    return removed;\n  }\n  /** packet interface  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** Receive a single packet from the wire, and determine what to do with it.\n   *  It's assumed that _ingestClientPacket() has already handled\n   *  authentication for clients before this method is received.\n   *  The packet has several possible processing options!\n   *  - packet is response to an outgoing transaction\n   *  - packet is a message that we handle\n   *  - packet is a message that we forward\n   *  - packet is unknown message so we return it with error\n   *  If the packet has the rsvp flag set, we need to return\n   *  it to the source address in the packet with any data\n   */\n  async dispatchPacket(pkt) {\n    const fn = \"dispatchPacket:\";\n    if (pkt.isResponse()) {\n      if (pkt.src_addr === this.uaddr) {\n        this.resolveTransaction(pkt);\n      } else {\n        this.returnToSender(pkt);\n      }\n      return;\n    }\n    if (!pkt.isRequest()) {\n      LOG2(PR2, this.uaddr, fn, `invalid packet`, pkt);\n      return;\n    }\n    if (pkt.msg_type === \"ping\") {\n      const pingArr = this.getMessageAddresses(pkt.msg);\n      const pingHandlers = this.getMessageHandlers(pkt.msg);\n      if (pingHandlers.length > 0) pingArr.push(this.uaddr);\n      pkt.setData(pingArr);\n      this.returnToSender(pkt);\n      return;\n    }\n    if (pkt.msg_type === \"signal\") {\n      await this.awaitHandlers(pkt);\n      if (this.isServer()) await this.awaitRemoteHandlers(pkt);\n      return;\n    }\n    let retData;\n    if (this.packetHasHandler(pkt)) {\n      retData = await this.awaitHandlers(pkt);\n      if (this.isServer()) retData = await this.awaitRemoteHandlers(pkt);\n    } else {\n      LOG2(PR2, this.uaddr, fn, `unknown message`, pkt);\n      retData = { error: `unknown message '${pkt.msg}'` };\n    }\n    if (!pkt.hasRsvp()) return;\n    if (pkt.msg_type === \"call\") {\n      pkt.data = NormalizeData(retData);\n    } else if (pkt.msg_type === \"send\") {\n      pkt.data = true;\n    }\n    this.returnToSender(pkt);\n  }\n  /** Start a transaction, which returns promises to await. This method\n   *  is a queue that uses Promises to wait for the return, which is\n   *  triggered by a returning packet in dispatchPacket(pkt).\n   */\n  async awaitRemoteHandlers(pkt) {\n    const fn = \"awaitRemoteHandlers:\";\n    if (pkt.hop_dir !== \"req\") throw Error(`${fn} packet is not a request`);\n    const { gateway, clients } = this.getRoutingInformation(pkt);\n    const promises = [];\n    if (gateway) {\n      const p = this.awaitTransaction(pkt, gateway);\n      if (p) promises.push(p);\n    }\n    if (Array.isArray(clients)) {\n      clients.forEach((sock) => {\n        const p = this.awaitTransaction(pkt, sock);\n        if (p) promises.push(p);\n      });\n    }\n    let data = await Promise.all(promises);\n    return data;\n  }\n  /** Start a handler call, which might have multiple implementors.\n   *  Returns data from all handlers as an array or a single item\n   */\n  async awaitHandlers(pkt) {\n    const fn = \"awaitHandlers:\";\n    const { msg } = pkt;\n    const handlers = this.getMessageHandlers(msg);\n    if (handlers.length === 0) return Promise.resolve([]);\n    const promises = [];\n    handlers.forEach((handler) => {\n      promises.push(\n        new Promise((resolve, reject) => {\n          try {\n            resolve(handler({ ...pkt.data }));\n          } catch (err) {\n            reject(err);\n          }\n        })\n      );\n    });\n    let data = await Promise.all(promises);\n    return data;\n  }\n  /** Send a single packet on all available interfaces based on the\n   *  message. Use for initial outgoing packets only from the\n   *  netCall, netSend, netSignal, and netPing methods.\n   */\n  initialSend(pkt) {\n    const fn = \"initialSend:\";\n    if (pkt.src_addr === void 0) throw Error(`${fn}src_addr undefined`);\n    if (this.uaddr === void 0) throw Error(`${fn} uaddr undefined`);\n    if (pkt.hop_seq.length !== 0) throw Error(`${fn} pkt must have no hops yet`);\n    if (pkt.msg_type !== \"ping\" && pkt.data === void 0)\n      throw Error(`${fn} data undefined`);\n    const { gateway, clients } = this.getRoutingInformation(pkt);\n    pkt.addHop(this.uaddr);\n    if (gateway) {\n      if (this.cli_reg === void 0) throw Error(`${fn} endpoint not registered`);\n      gateway.send(pkt);\n    }\n    if (Array.isArray(clients)) {\n      clients.forEach((sock) => sock.send(pkt));\n    }\n  }\n  /** Used to forward a transaction from server to a remote client\n   */\n  awaitTransaction(pkt, sock) {\n    const clone = this.clonePacket(pkt);\n    clone.id = this.assignPacketId(clone);\n    if (pkt.src_addr === sock.uaddr && SkipOriginType(pkt.msg_type)) return;\n    return this._queueTransaction(clone, sock);\n  }\n  /** Used to resolve a forwarded transaction received by server from\n   *  a remote client\n   */\n  resolveTransaction(pkt) {\n    const fn = \"resolveTransaction:\";\n    if (pkt.hop_rsvp !== true) throw Error(`${fn} packet is not RSVP`);\n    if (pkt.hop_dir !== \"res\") throw Error(`${fn} packet is not a response`);\n    if (pkt.hop_seq.length < 2 && !pkt.isSpecialPkt())\n      throw Error(`${fn} packet has no hops`);\n    this._dequeueTransaction(pkt);\n  }\n  /** utility method for conducting transactions */\n  _queueTransaction(pkt, sock) {\n    const fn = \"_queueTransaction:\";\n    const hash = GetPacketHashString(pkt);\n    if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n    const { src_addr } = pkt;\n    const { uaddr: dst_addr } = sock;\n    return new Promise((resolve, reject) => {\n      const meta = { msg: pkt.msg, uaddr: pkt.src_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      sock.send(pkt);\n    });\n  }\n  /** utility method for completing transactions */\n  _dequeueTransaction(pkt) {\n    const fn = \"_finishTransaction:\";\n    const hash = GetPacketHashString(pkt);\n    const resolver = this.transactions.get(hash);\n    if (!resolver) throw Error(`${fn} no resolver for hash ${hash}`);\n    const { resolve, reject } = resolver;\n    const { data } = pkt;\n    if (pkt.err) reject(pkt.err);\n    else resolve(data);\n    this.transactions.delete(hash);\n  }\n  /** Return a packet to its source address. If this endpoint is a server,\n   *  then it might have the socket stored. Otherwise, if this endpoint is\n   *  also a client of another server, pass the back through the gateway.\n   *  This is used by server endpoints to return packets to clients.\n   */\n  returnToSender(pkt) {\n    const fn = \"returnToSender:\";\n    if (pkt.hop_rsvp !== true) throw Error(`${fn} packet is not RSVP`);\n    if (pkt.hop_seq.length < 1) throw Error(`${fn} packet has no hops`);\n    pkt.setDir(\"res\");\n    pkt.addHop(this.uaddr);\n    const { gateway, src_addr } = this.getRoutingInformation(pkt);\n    if (this.isServer()) {\n      const socket = this.getClient(src_addr);\n      if (socket) socket.send(pkt);\n      return;\n    }\n    if (gateway) {\n      gateway.send(pkt);\n      return;\n    }\n    LOG2(PR2, `${fn} unroutable packet`, pkt);\n  }\n  /** return array of sockets to use for sending packet,\n   *  based on pkt.msg and pkt.src_addr\n   */\n  getRoutingInformation(pkt) {\n    const fn = \"getRoutingInformation:\";\n    const { msg, src_addr } = pkt;\n    if (!IsNetMessage(msg)) throw Error(`${fn} '${msg}' is invalid message`);\n    const gateway = this.cli_gateway;\n    const self_addr = this.uaddr;\n    const msg_list = this.getMessageAddresses(msg);\n    const clients = [];\n    msg_list.forEach((uaddr) => {\n      if (uaddr === this.uaddr) return;\n      const socket = this.getClient(uaddr);\n      if (socket) clients.push(socket);\n    });\n    return {\n      msg,\n      src_addr,\n      self_addr,\n      gateway,\n      clients\n    };\n  }\n  /** packet utility - - - - - - - - - - - - - - - - - - - - - - - - - - - -**/\n  assignPacketId(pkt) {\n    if (pkt.src_addr === void 0) pkt.src_addr = this.uaddr;\n    const count = ++this.pkt_counter;\n    pkt.id = `pkt[${pkt.src_addr}:${count}]`;\n    return pkt.id;\n  }\n  /** convert JSON to packet and return */\n  packetFromJSON(json) {\n    const pkt = new class_urnet_packet_default();\n    pkt.setFromJSON(json);\n    return pkt;\n  }\n  /** create a new packet with proper address */\n  newPacket(msg, data) {\n    const fn = \"newPacket:\";\n    const pkt = new class_urnet_packet_default(msg, data);\n    pkt.setSrcAddr(this.uaddr || UADDR_NONE);\n    if (this.cli_auth) pkt.setAuth(this.cli_auth);\n    pkt.id = this.assignPacketId(pkt);\n    return pkt;\n  }\n  /** clone a packet with new id */\n  clonePacket(pkt) {\n    const clone = this.newPacket(pkt.msg, pkt.data);\n    clone.setFromJSON(pkt.serialize());\n    clone.src_addr = this.uaddr;\n    clone.id = this.assignPacketId(clone);\n    return clone;\n  }\n  /** create an authentication packet, which is the first packet that must be sent\n   *  after connecting to the server */\n  newAuthPacket(authObj) {\n    const pkt = this.newPacket(\"SRV:AUTH\", { ...authObj });\n    pkt.setMeta(\"_auth\", { rsvp: true });\n    pkt.setSrcAddr(UADDR_NONE);\n    this.assignPacketId(pkt);\n    return pkt;\n  }\n  /** create a registration packet */\n  newRegPacket() {\n    const pkt = this.newPacket(\"SRV:REG\");\n    pkt.setMeta(\"_reg\", { rsvp: true });\n    return pkt;\n  }\n  /** create a declaration packet shell */\n  newDeclPacket() {\n    const pkt = this.newPacket(\"SRV:DEF\");\n    pkt.setMeta(\"_decl\", { rsvp: true });\n    return pkt;\n  }\n  /** environment utilities - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** return true if this endpoint is managing connections */\n  isServer() {\n    return this.client_socks !== void 0 && this.remoted_msgs !== void 0;\n  }\n  /** socket utilities  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** given a socket, see if it's already registered */\n  isNewSocket(socket) {\n    const fn = \"isNewSocket:\";\n    if (typeof socket !== \"object\") return false;\n    return socket.uaddr === void 0;\n  }\n  /** client endpoints need to have an authentication token to\n   *  access URNET beyond registration\n   */\n  authorizeSocket(auth) {\n    const fn = \"authorizeSocket:\";\n    LOG2(PR2, this.uaddr, \"would check auth token\");\n  }\n};\nvar class_urnet_endpoint_default = NetEndpoint;\n\n// _ur/common/class-urnet-socket.ts\nvar PR3 = typeof process !== \"undefined\" ? \"Socket\".padEnd(13) : \"Socket:\";\nvar NetSocket = class {\n  // name of the socket-ish object\n  constructor(connectObj, io) {\n    __publicField(this, \"connector\");\n    // the original connection object\n    __publicField(this, \"sendFunc\");\n    // the outgoing send function for this socket\n    __publicField(this, \"closeFunc\");\n    // function to disconnect\n    __publicField(this, \"onDataFunc\");\n    // the incoming data function for this socket\n    //\n    __publicField(this, \"uaddr\");\n    // assigned uaddr for this socket-ish object\n    __publicField(this, \"auth\");\n    // whatever authentication is needed for this socket\n    __publicField(this, \"msglist\");\n    // messages queued for this socket\n    __publicField(this, \"age\");\n    // number of seconds since this socket was used\n    __publicField(this, \"label\");\n    this.connector = connectObj;\n    const { send, onData, close } = io;\n    this.sendFunc = send.bind(connectObj);\n    this.closeFunc = close.bind(connectObj);\n    this.onDataFunc = onData.bind(connectObj);\n  }\n  send(pkt) {\n    this.sendFunc(pkt);\n  }\n  close() {\n    this.closeFunc();\n  }\n  getConnector() {\n    return this.connector;\n  }\n  authenticated() {\n    let a = this.auth !== void 0;\n    return a;\n  }\n};\nvar class_urnet_socket_default = NetSocket;\n\n// _ur/browser-client/urnet-browser.ts\nvar PR4 = util_prompts_default.makeStyleFormatter(\"URNET\", \"TagPurple\");\nvar LOG3 = console.log.bind(console);\nvar DBG = false;\nvar TIMEOUT = 360;\nvar EP = new class_urnet_endpoint_default();\nvar SERVER_LINK;\nvar EP_UADDR = EP.uaddr;\nvar LISTENER_COUNT = 0;\nfunction m_Sleep(ms, resolve) {\n  return new Promise(\n    (localResolve) => setTimeout(() => {\n      if (typeof resolve === \"function\") resolve();\n      localResolve();\n    }, ms)\n  );\n}\nfunction m_DisconnectListener() {\n  EP.disconnectAsClient();\n}\nfunction Connect() {\n  const wss_url = \"/webplay-ws\";\n  const promiseConnect = new Promise((resolve) => {\n    SERVER_LINK = new WebSocket(wss_url);\n    SERVER_LINK.addEventListener(\"open\", async () => {\n      let out = `Connected to ${wss_url}`;\n      LOG3(...PR4(out));\n      const send = (pkt) => SERVER_LINK.send(pkt.serialize());\n      const onData = (event) => EP._ingestServerPacket(event.data, client_sock);\n      const close = () => SERVER_LINK.close();\n      const client_sock = new class_urnet_socket_default(SERVER_LINK, { send, onData, close });\n      SERVER_LINK.addEventListener(\"message\", onData);\n      SERVER_LINK.addEventListener(\"close\", () => {\n        out = `Server closed connection.`;\n        LOG3(...PR4(out));\n        EP.disconnectAsClient();\n      });\n      if (LISTENER_COUNT === 0) {\n        window.addEventListener(\"beforeunload\", m_DisconnectListener);\n        LISTENER_COUNT++;\n      }\n      const auth = { identity: \"my_voice_is_my_passport\", secret: \"crypty\" };\n      const resdata = await EP.connectAsClient(client_sock, auth);\n      if (DBG) LOG3(...PR4(\"EP.connectAsClient returned\", resdata));\n      if (resdata.error) {\n        console.error(resdata.error);\n        resolve(false);\n        return;\n      }\n      const info = { name: \"UDSClient\", type: \"client\" };\n      const regdata = await EP.declareClientProperties(info);\n      if (DBG) LOG3(...PR4(\"EP.declareClientProperties returned\", regdata));\n      if (regdata.error) {\n        console.error(regdata.error);\n        resolve(false);\n        return;\n      }\n      EP_UADDR = EP.uaddr;\n      resolve(true);\n    });\n  });\n  return promiseConnect;\n}\nasync function RegisterMessages() {\n  const resdata = await EP.declareClientMessages();\n  if (DBG) LOG3(...PR4(\"EP.declareClientMessages returned\", resdata));\n}\nfunction Disconnect(seconds = TIMEOUT) {\n  return new Promise((resolve, reject) => {\n    LOG3(...PR4(`waiting for ${seconds} seconds...`));\n    if (LISTENER_COUNT > 0) {\n      window.removeEventListener(\"beforeunload\", m_DisconnectListener);\n      LISTENER_COUNT--;\n    }\n    m_Sleep(seconds * 1e3, () => {\n      resolve(true);\n      SERVER_LINK.close();\n      let out = `Client closing connection.`;\n      LOG3(...PR4(out));\n    });\n  });\n}\nasync function EX_Start() {\n  await Connect();\n  EP.addMessageHandler(\"NET:HOT_RELOAD_APP\", (data) => {\n    LOG3(...PR4(`HOT_RELOAD_APP`));\n    window.location.reload();\n  });\n  await RegisterMessages();\n}\n\n// _ur/common/lib-uid.ts\nvar lib_uid_exports = {};\n__export(lib_uid_exports, {\n  DecodeID: () => DecodeID,\n  GetDefaultSchema: () => GetDefaultSchema,\n  IsValidFormat: () => IsValidFormat,\n  IsValidPrefix: () => IsValidPrefix,\n  IsValidSchema: () => IsValidSchema,\n  NewFullID: () => NewFullID,\n  NewID: () => NewID,\n  PrefixShortID: () => PrefixShortID,\n  SetDefaultSchema: () => SetDefaultSchema\n});\nvar SCHEMAS = {\n  \"meme\": {\n    \"n\": \"node\",\n    \"e\": \"edge\",\n    \"p\": \"project\"\n  }\n};\nvar DEFAULT_SCHEMA = \"\";\nvar ID_COUNTER = 0;\nfunction DecodeID(uid) {\n  if (!IsValidFormat(uid)) return [];\n  let bits = uid.split(\":\");\n  if (bits.length < 1 || bits.length > 2) return [];\n  if (bits.length === 1) bits.unshift(\"\");\n  const [schema, prefix] = bits;\n  bits = prefix.split(\"-\");\n  if (bits.length !== 2) return [];\n  return [schema, ...bits];\n}\nfunction NewID(prefix, int) {\n  const fn = \"ShortID:\";\n  if (int !== void 0) {\n    if (typeof int !== \"number\") throw new Error(`${fn} invalid id ${int}`);\n    if (int < 0) throw new Error(`${fn} negative id ${int}`);\n    if (int % 1 !== 0) throw new Error(`${fn} non-integer id ${int}`);\n  } else {\n    int = ID_COUNTER++;\n  }\n  const uid = `${prefix}-${int}`;\n  return uid;\n}\nfunction NewFullID(schema, prefix, int) {\n  const fn = \"EncodeID:\";\n  const shortUID = NewID(prefix, int);\n  if (!IsValidSchema(schema)) throw new Error(`${fn} unknown schema ${schema}`);\n  if (!IsValidPrefix(`${schema}:${prefix}`))\n    throw new Error(`${fn} unknown prefix ${prefix}`);\n  const uid = `${schema}:${prefix}-${int}`;\n  return uid;\n}\nfunction PrefixShortID(uid, prefix) {\n  const [_, id] = DecodeID(uid);\n  return NewID(prefix, parseInt(id));\n}\nfunction IsValidFormat(uid) {\n  const isLowerCase = uid === uid.toLowerCase();\n  const isFullForm = /^[\\w]+:[\\w]+-[\\d]+$/.test(uid);\n  const isShortForm = /^[\\w]+-[\\d]+$/.test(uid);\n  return isLowerCase && (isFullForm || isShortForm);\n}\nfunction IsValidSchema(schema) {\n  return Object.keys(SCHEMAS).includes(schema);\n}\nfunction IsValidPrefix(sch_pre) {\n  const fn = \"IsValidPrefix:\";\n  const bits = sch_pre.split(\":\");\n  if (bits.length > 2) throw new Error(`${fn} Invalid schema prefix ${sch_pre}`);\n  if (bits.length === 1) bits.unshift(\"\");\n  const [schema, prefix] = bits;\n  const isValidSchema = IsValidSchema(schema);\n  const isValidPrefix = Object.keys(SCHEMAS[schema]).includes(prefix);\n  return isValidSchema && isValidPrefix;\n}\nfunction SetDefaultSchema(schema) {\n  const fn = \"SetDefaultSchema:\";\n  if (!IsValidSchema(schema)) throw new Error(`${fn} Invalid schema ${schema}`);\n  DEFAULT_SCHEMA = schema;\n}\nfunction GetDefaultSchema() {\n  return DEFAULT_SCHEMA;\n}\n\n// _ur/common/constants-urnet-web.ts\nvar http_host = \"127.0.0.1\";\nvar http_port = 8080;\nvar wss_path = \"urnet-http\";\nvar HTTP_CLIENT_INFO = {\n  http_host,\n  http_port,\n  http_url: `http://${http_host}:${http_port}`,\n  //\n  wss_path,\n  wss_url: `ws://${http_host}:${http_port}/${wss_path}`\n};\nfunction GetClientInfoFromWindowLocation(winLocation) {\n  const { host, pathname, protocol } = winLocation;\n  const { http_port: http_port2, wss_path: wss_path2 } = HTTP_CLIENT_INFO;\n  const tls = protocol === \"https:\";\n  const hostpath = host + pathname;\n  const http_url = tls ? `https://${hostpath}` : `http://${hostpath}`;\n  const wss_url = tls ? `wss://${hostpath}/${wss_path2}` : `ws://${hostpath}${wss_path2}`;\n  let new_info = {\n    ...HTTP_CLIENT_INFO,\n    http_host: hostpath,\n    http_url,\n    wss_url\n  };\n  HTTP_CLIENT_INFO = new_info;\n  return new_info;\n}\n\n// _ur/browser-client/@client.ts\nvar { makeStyleFormatter: makeStyleFormatter2 } = util_prompts_default;\nvar PR5 = makeStyleFormatter2(\"UR\", \"TagCyan\");\nvar CLASS = {\n  OpSequencer: class_op_seq_default,\n  StateMgr: class_state_mgr_default,\n  NetSocket: class_urnet_socket_default,\n  NetEndpoint: class_urnet_endpoint_default,\n  NetPacket: class_urnet_packet_default\n};\nvar LIB = {\n  UID: lib_uid_exports\n};\nvar CONSTANT = {\n  URNET: { ...HTTP_CLIENT_INFO, GetClientInfoFromWindowLocation }\n};\nfunction ClientTest() {\n  console.log(...PR5(\"System Integration of new URSYS module successful!\"));\n}\n//# sourceMappingURL=client-cjs.js.map\n  })();\n});"]}