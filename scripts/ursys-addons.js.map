{"version":3,"sources":["node_modules/@ursys/addons/_dist/addons-client-cjs.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/scripts/ursys-addons.js","sourcesContent":["\nrequire.register(\"@ursys/addons/_dist/addons-client-cjs.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"@ursys/addons\");\n  (function() {\n    var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// _ur_addons/@addons-client.ts\nvar addons_client_exports = {};\n__export(addons_client_exports, {\n  AddonClientTest: () => AddonClientTest,\n  CLASS: () => CLASS2,\n  COMMENT: () => ac_comment_exports\n});\nmodule.exports = __toCommonJS(addons_client_exports);\n\n// _ur/_dist/client-esm.js\nvar client_esm_exports = {};\n__export(client_esm_exports, {\n  CLASS: () => CLASS,\n  CLIENT_EP: () => urnet_browser_exports,\n  CONSTANT: () => CONSTANT,\n  ClientTest: () => ClientTest,\n  ConsoleStyler: () => makeStyleFormatter2,\n  LIB: () => LIB,\n  PROMPTS: () => util_prompts_default,\n  StateMgr: () => class_state_mgr_default,\n  TEXT: () => export_TEXT\n});\nvar __create = Object.create;\nvar __defProp2 = Object.defineProperty;\nvar __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames2 = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp2 = Object.prototype.hasOwnProperty;\nvar __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export2 = (target, all) => {\n  for (var name in all)\n    __defProp2(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps2 = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames2(from))\n      if (!__hasOwnProp2.call(to, key) && key !== except)\n        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps2(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar require_util_text = __commonJS({\n  \"_ur/common/util-text.ts\"(exports, module2) {\n    function PreprocessDataText(str) {\n      let normalizedStr = str.replace(/\\r\\n|\\r/g, \"\\n\");\n      normalizedStr = normalizedStr.split(\"\\n\").map((line) => line.replace(/\\s+$/, \"\")).map((line) => line.replace(/^\\s+/, \"\")).join(\"\\n\");\n      normalizedStr = normalizedStr.replace(/\\t/g, \"  \");\n      let lines = normalizedStr.split(\"\\n\");\n      const processDelimited = (line, delimiter) => {\n        let parts = line.split(delimiter);\n        for (let i = 0; i < parts.length; i++) {\n          parts[i] = parts[i].trim();\n          parts[i] = parts[i].replace(/\\s+/g, \" \");\n        }\n        return parts.join(delimiter);\n      };\n      for (let i = 0; i < lines.length; i++) {\n        lines[i] = processDelimited(lines[i], \",\");\n        lines[i] = processDelimited(lines[i], \":\");\n      }\n      normalizedStr = lines.join(\"\\n\").trim();\n      return normalizedStr + \"\\n\";\n    }\n    module2.exports = {\n      PreprocessDataText\n    };\n  }\n});\nvar TERM_COLORS = {\n  // TOUT = makeTerminalOut(str); TOUT('hi')\n  Reset: \"\\x1B[0m\",\n  Bright: \"\\x1B[1m\",\n  Dim: \"\\x1B[2m\",\n  Underscore: \"\\x1B[4m\",\n  Blink: \"\\x1B[5m\",\n  Reverse: \"\\x1B[7m\",\n  Hidden: \"\\x1B[8m\",\n  //\n  Black: \"\\x1B[30m\",\n  White: \"\\x1B[37m\",\n  Red: \"\\x1B[31m\",\n  Orange: \"\\x1B[38;5;202m\",\n  Yellow: \"\\x1B[33m\",\n  Green: \"\\x1B[32m\",\n  Cyan: \"\\x1B[36m\",\n  Blue: \"\\x1B[34m\",\n  Purple: \"\\x1B[35m\",\n  //\n  BgBlack: \"\\x1B[40m\",\n  BgGray: \"\\x1B[100m\",\n  BgWhite: \"\\x1B[47m\",\n  BgRed: \"\\x1B[41m\",\n  BgOrange: \"\\x1B[48;5;202m\",\n  BgYellow: \"\\x1B[43m\",\n  BgCyan: \"\\x1B[46m\",\n  BgGreen: \"\\x1B[42m\",\n  BgBlue: \"\\x1B[44m\",\n  BgPurple: \"\\x1B[45m\",\n  BgPink: \"\\x1B[105m\",\n  // FORMATS\n  TagBlack: \"\\x1B[30;1m\",\n  TagWhite: \"\\x1B[37;1m\",\n  TagRed: \"\\x1B[41;37m\",\n  TagOrange: \"\\x1B[43;37m\",\n  TagYellow: \"\\x1B[43;30m\",\n  TagGreen: \"\\x1B[42;30m\",\n  TagCyan: \"\\x1B[46;37m\",\n  TagBlue: \"\\x1B[44;37m\",\n  TagPurple: \"\\x1B[45;37m\",\n  TagPink: \"\\x1B[105;1m\",\n  TagGray: \"\\x1B[100;37m\",\n  TagNull: \"\\x1B[2;37m\"\n};\nvar CSS_COMMON = \"padding:3px 5px;border-radius:2px;\";\nvar CSS_COLORS = {\n  Reset: \"color:auto;background-color:auto\",\n  // COLOR FOREGROUND\n  Black: \"color:black\",\n  White: \"color:white\",\n  Red: \"color:red\",\n  Orange: \"color:orange\",\n  Yellow: \"color:orange\",\n  Green: \"color:green\",\n  Cyan: \"color:cyan\",\n  Blue: \"color:blue\",\n  Magenta: \"color:magenta\",\n  Pink: \"color:pink\",\n  // COLOR BACKGROUND\n  TagRed: `color:#000;background-color:#f66;${CSS_COMMON}`,\n  TagOrange: `color:#000;background-color:#fa4;${CSS_COMMON}`,\n  TagYellow: `color:#000;background-color:#fd4;${CSS_COMMON}`,\n  TagGreen: `color:#000;background-color:#5c8;${CSS_COMMON}`,\n  TagCyan: `color:#000;background-color:#2dd;${CSS_COMMON}`,\n  TagBlue: `color:#000;background-color:#2bf;${CSS_COMMON}`,\n  TagPurple: `color:#000;background-color:#b6f;${CSS_COMMON}`,\n  TagPink: `color:#000;background-color:#f9f;${CSS_COMMON}`,\n  TagGray: `color:#fff;background-color:#999;${CSS_COMMON}`,\n  TagNull: `color:#999;border:1px solid #ddd;${CSS_COMMON}`,\n  // COLOR BACKGROUND DARK (BROWSER ONLY)\n  TagDkRed: `color:white;background-color:maroon;${CSS_COMMON}`,\n  TagDkOrange: `color:white;background-color:burntorange;${CSS_COMMON}`,\n  TagDkYellow: `color:white;background-color:brown;${CSS_COMMON}`,\n  TagDkGreen: `color:white;background-color:forestgreen;${CSS_COMMON}`,\n  TagDkCyan: `color:white;background-color:cerulean;${CSS_COMMON}`,\n  TagDkBlue: `color:white;background-color:darkblue;${CSS_COMMON}`,\n  TagDkPurple: `color:white;background-color:indigo;${CSS_COMMON}`,\n  TagDkPink: `color:white;background-color:fuchsia;${CSS_COMMON}`\n};\nTERM_COLORS.TagBuild = TERM_COLORS.TagGray;\nTERM_COLORS.TagError = TERM_COLORS.TagRed;\nTERM_COLORS.TagAlert = TERM_COLORS.TagOrange;\nTERM_COLORS.TagTest = TERM_COLORS.TagRed;\nTERM_COLORS.TagSystem = TERM_COLORS.TagGray;\nTERM_COLORS.TagServer = TERM_COLORS.TagGray;\nTERM_COLORS.TagDatabase = TERM_COLORS.TagCyan;\nTERM_COLORS.TagNetwork = TERM_COLORS.TagCyan;\nTERM_COLORS.TagUR = TERM_COLORS.TagBlue;\nTERM_COLORS.TagURNET = TERM_COLORS.TagBlue;\nTERM_COLORS.TagURMOD = TERM_COLORS.TagBlue;\nTERM_COLORS.TagAppMain = TERM_COLORS.TagGreen;\nTERM_COLORS.TagAppModule = TERM_COLORS.TagGreen;\nTERM_COLORS.TagAppState = TERM_COLORS.TagGreen;\nTERM_COLORS.TagAppCore = TERM_COLORS.TagGreen;\nTERM_COLORS.TagDataCore = TERM_COLORS.TagGreen;\nTERM_COLORS.TagUI = TERM_COLORS.TagPurple;\nTERM_COLORS.TagPhase = TERM_COLORS.TagPink;\nTERM_COLORS.TagEvent = TERM_COLORS.TagPink;\nTERM_COLORS.TagStream = TERM_COLORS.TagPink;\nCSS_COLORS.TagDebug = `color:#fff;background-color:IndianRed;${CSS_COMMON}`;\nCSS_COLORS.TagWarning = `color:#fff;background:linear-gradient(\n  -45deg,\n  rgb(29,161,242),\n  rgb(184,107,107),\n  rgb(76,158,135)\n);${CSS_COMMON}`;\nCSS_COLORS.TagTest = CSS_COLORS.TagRed;\nCSS_COLORS.TagSystem = CSS_COLORS.TagGray;\nCSS_COLORS.TagServer = CSS_COLORS.TagGray;\nCSS_COLORS.TagDatabase = CSS_COLORS.TagCyan;\nCSS_COLORS.TagNetwork = CSS_COLORS.TagCyan;\nCSS_COLORS.TagUR = `color:CornflowerBlue;border:1px solid CornflowerBlue;${CSS_COMMON}`;\nCSS_COLORS.TagURNET = `color:#fff;background-color:MediumSlateBlue;${CSS_COMMON}`;\nCSS_COLORS.TagURMOD = `color:#fff;background:linear-gradient(\n  -45deg,\n  CornflowerBlue 0%,\n  LightSkyBlue 25%,\n  RoyalBlue 100%\n);${CSS_COMMON}`;\nCSS_COLORS.TagAppMain = CSS_COLORS.TagGreen;\nCSS_COLORS.TagAppModule = CSS_COLORS.TagGreen;\nCSS_COLORS.TagAppState = `color:#fff;background-color:Navy;${CSS_COMMON}`;\nCSS_COLORS.TagUI = CSS_COLORS.TagDkOrange;\nCSS_COLORS.TagEvent = CSS_COLORS.TagDkOrange;\nCSS_COLORS.TagStream = CSS_COLORS.TagDkOrange;\nCSS_COLORS.TagPhase = `color:#fff;background-color:MediumVioletRed;${CSS_COMMON}`;\nvar IS_NODE = typeof window === \"undefined\";\nvar IS_MOBILE = !IS_NODE && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n  navigator.userAgent\n);\nvar DEFAULT_PADDING = IS_NODE ? 10 : 8;\nvar DEFAULT_SPACE = IS_NODE ? \" \".padStart(DEFAULT_PADDING, \" \") : \" \".padStart(DEFAULT_PADDING + 4, \" \");\nvar DEFAULT_COLOR = \"TagNull\";\nvar SHOW = true;\nvar PROMPT_DICT = {\n  // URSYS-RELATED MODULES\n  \"UR\": [SHOW, \"TagRed\"],\n  // SERVERS\n  \"APPSRV\": [SHOW, \"Yellow\"],\n  \"GEMSRV\": [SHOW, \"Yellow\"],\n  // SPECIAL\n  \"-\": [SHOW, \"TagNull\"]\n};\nfunction padString(str, padding = DEFAULT_PADDING) {\n  let len = str.length;\n  const nbsp = String.fromCharCode(160);\n  if (IS_NODE) return `${str.padEnd(padding, \" \")}`;\n  if (padding === 0) return `${str}`;\n  if (len >= padding) str = str.substr(0, padding);\n  else str = str.padEnd(padding, nbsp);\n  return `${str}`;\n}\nfunction m_SetPromptColors(match, color = DEFAULT_COLOR) {\n  if (typeof match !== \"string\") throw Error(\"match prompt must be string\");\n  match = match.trim();\n  if (match === \"\") throw Error(\"match prompt cannot be empty\");\n  let colorTable = IS_NODE ? TERM_COLORS : CSS_COLORS;\n  let validColor = false;\n  validColor = colorTable[color] !== void 0;\n  if (!validColor) colorTable = IS_NODE ? CSS_COLORS : TERM_COLORS;\n  validColor = colorTable[color] !== void 0;\n  if (!validColor)\n    throw Error(`prompt color ${color} is not defined in either table`);\n  PROMPT_DICT[match] = [true, color];\n  return colorTable;\n}\nfunction m_GetEnvColor(prompt, tagColor) {\n  const colorTable = m_SetPromptColors(prompt, tagColor);\n  const [dbg_mode, defcol] = PROMPT_DICT[prompt.trim()] || [SHOW, DEFAULT_COLOR];\n  const ucolor = colorTable[tagColor];\n  const dcolor = colorTable[defcol];\n  const color = ucolor || dcolor;\n  const reset = colorTable.Reset;\n  return [dbg_mode, color, reset];\n}\nfunction m_MakeColorArray(prompt, colorName) {\n  const [dbg, color, reset] = m_GetEnvColor(prompt, colorName);\n  if (!(dbg || IS_NODE)) return [];\n  return IS_NODE ? [`${color}${padString(prompt)}${reset}   `] : [`%c${padString(prompt)}%c `, color, reset];\n}\nfunction m_MakeColorPromptFunction(prompt, colorName, opt = {}) {\n  const textColor = opt.color || \"Reset\";\n  const dim = opt.dim || false;\n  return IS_NODE ? (str, ...args) => {\n    if (args === void 0) args = \"\";\n    let TAG = TERM_COLORS[colorName];\n    let TEXT2 = TERM_COLORS[textColor];\n    let RST = TERM_COLORS.Reset;\n    let PR62 = padString(prompt);\n    if (dim) TEXT2 += TERM_COLORS.Dim;\n    console.log(`${RST}${TAG}${PR62}${RST}${TEXT2}    ${str}`, ...args, RST);\n  } : (str, ...args) => {\n    if (args === void 0) args = \"\";\n    let TEXT2 = TERM_COLORS[textColor];\n    let RST = CSS_COLORS.Reset;\n    let PR62 = padString(prompt);\n    console.log(`%c${PR62}%c%c ${str}`, RST, TEXT2, ...args);\n  };\n}\nfunction makeStyleFormatter(prompt, tagColor) {\n  if (prompt.startsWith(\"UR\") && tagColor === void 0) tagColor = \"TagUR\";\n  let outArray = m_MakeColorArray(prompt, tagColor);\n  if (outArray.length === 0) return () => [];\n  if (IS_MOBILE) outArray = [`${prompt}:`];\n  const f = (str, ...args) => [...outArray, str, ...args];\n  f._ = `\n${DEFAULT_SPACE}`;\n  return f;\n}\nfunction makeTerminalOut(prompt, tagColor = DEFAULT_COLOR) {\n  const wrap = m_MakeColorPromptFunction(prompt, tagColor);\n  wrap.warn = m_MakeColorPromptFunction(prompt, \"TagYellow\", { color: \"Yellow\" });\n  wrap.error = m_MakeColorPromptFunction(prompt, \"TagRed\", { color: \"Red\" });\n  wrap.fail = m_MakeColorPromptFunction(prompt, \"Red\", { color: \"Red\" });\n  wrap.pass = m_MakeColorPromptFunction(prompt, \"Green\", { color: \"Green\" });\n  wrap.info = m_MakeColorPromptFunction(prompt, \"TagGray\", { dim: true });\n  wrap.DIM = \"\\x1B[2m\";\n  wrap.BRI = \"\\x1B[1m\";\n  wrap.RST = \"\\x1B[0m\";\n  return wrap;\n}\nvar util_prompts_default = {\n  makeTerminalOut,\n  makeStyleFormatter,\n  padString\n};\nvar import_util_text = __toESM(require_util_text());\nvar OPSEQS = /* @__PURE__ */ new Map();\nfunction m_ValidateSeqName(sn) {\n  const fn = \"m_ValidateSeqName\";\n  const pcErr = \"name must be PascalCase string\";\n  if (sn === \"\") throw Error(`${fn}: ${pcErr}`);\n  if (sn === void 0) throw Error(`${fn}: ${pcErr}`);\n  if (typeof sn !== \"string\") throw Error(`${fn}: ${pcErr}`);\n  if (sn !== sn[0].toUpperCase() + sn.slice(1)) throw Error(`${fn}: ${pcErr}`);\n  if (sn.trim() !== sn)\n    throw Error(`${fn}: name must not have leading/trailing spaces`);\n}\nfunction m_ValidateActiveSeq(seq) {\n  if (seq instanceof OpSequencer) {\n    if (seq._disposed) throw Error(`sequencer ${seq.seqName} is disposed`);\n    else return;\n  }\n  throw Error(\"not a sequence instance or undefined\");\n}\nfunction m_ValidateNodeName(nn) {\n  const fn = \"m_ValidateNodeName\";\n  if (nn === \"\") throw Error(`${fn}: name must be lc string`);\n  if (nn === void 0) throw Error(`${fn}: name must be lc string`);\n  if (typeof nn !== \"string\") throw Error(`${fn}: name must be lc string`);\n  if (nn !== nn.toLowerCase()) throw Error(`${fn}: name must be lc`);\n  if (nn.trim() !== nn)\n    throw Error(`${fn}: name must not have leading/trailing spaces`);\n}\nvar OpSequencer = class _OpSequencer {\n  // true if disposed\n  constructor(seqName) {\n    __publicField2(this, \"ops\");\n    __publicField2(this, \"seqName\");\n    __publicField2(this, \"lastOp\");\n    __publicField2(this, \"currentOp\");\n    __publicField2(this, \"opIndex\");\n    __publicField2(this, \"opsMap\");\n    __publicField2(this, \"subs\");\n    __publicField2(this, \"_disposed\");\n    m_ValidateSeqName(seqName);\n    seqName = seqName.trim().toUpperCase();\n    if (OPSEQS.has(seqName)) {\n      console.warn(\n        `(not an error) '${seqName}' construction duplicate, returning existing instance`\n      );\n      return OPSEQS.get(seqName);\n    }\n    this.seqName = seqName;\n    this.ops = [];\n    this.opsMap = /* @__PURE__ */ new Map();\n    this.opIndex = -1;\n    this.currentOp = null;\n    this.lastOp = null;\n    this.subs = /* @__PURE__ */ new Map();\n    this._disposed = false;\n    OPSEQS.set(seqName, this);\n  }\n  /* --- add nodes --- */\n  /** given nodeName and a source TOpNode, add a clone of the source node to the sequencer */\n  addOp(name, data, opt) {\n    const fn = \"addOp\";\n    if (data === void 0) throw Error(`${fn}: arg2 must be TOpNode`);\n    if (typeof name !== \"string\") throw Error(`${fn}: arg1 must be name:string`);\n    if (typeof data._name === \"string\") throw Error(`${fn}: node ${name} reused`);\n    if (data._index !== void 0) throw Error(`${fn}: node ${name} reused`);\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(name);\n    if (this.opIndex !== -1) throw Error(`${fn}: sequencer already started`);\n    if (this.hasOp(name)) throw Error(`${fn}: node '${name}' already exists`);\n    const index = this.ops.length;\n    this.opsMap.set(name, index);\n    const newData = { ...data };\n    if (opt == null ? void 0 : opt.mutable) Object.freeze(newData);\n    const newNode = {\n      _opIndex: index,\n      _seqName: this.seqName,\n      _opName: name,\n      data: newData\n    };\n    this.ops.push(newNode);\n    return newNode;\n  }\n  deleteOp(name) {\n    const fn = \"deleteOp\";\n    console.error(`${fn}: not implemented by design`);\n  }\n  /* --- access operations --- */\n  data(key) {\n    m_ValidateActiveSeq(this);\n    if (typeof key === \"string\") return this.currentOp.data[key];\n    return this.currentOp.data;\n  }\n  length() {\n    m_ValidateActiveSeq(this);\n    return this.ops.length;\n  }\n  /* --- sequencer operations --- */\n  start() {\n    const fn = \"start\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex !== -1) throw Error(`${fn}: sequencer already started`);\n    if (this.ops.length === 0) throw Error(`${fn}: no operations to run`);\n    this.opIndex = 0;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  current() {\n    const fn = \"current\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1) throw Error(`${fn}: sequencer not started`);\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  stop() {\n    const fn = \"stop\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1) throw Error(\"stop: sequencer not started\");\n    this.opIndex = -1;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  next() {\n    const fn = \"next\";\n    if (this.opIndex === -1) return this.start();\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === this.ops.length - 1) return void 0;\n    ++this.opIndex;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  previous() {\n    const fn = \"previous\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1) throw Error(`${fn}: sequencer not started`);\n    if (this.opIndex === 0) return void 0;\n    --this.opIndex;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  /* --- node events --- */\n  subscribe(opName, subf) {\n    const fn = \"onEnter\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    if (!this.hasOp(opName)) throw Error(`${fn}: node '${opName}' does not exist`);\n    if (!this.subs.has(opName)) this.subs.set(opName, /* @__PURE__ */ new Set());\n    this.subs.get(opName).add(subf);\n  }\n  unsubscribe(name, subf) {\n    const fn = \"onEnter\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(name);\n    if (!this.hasOp(name)) throw Error(`${fn}: node '${name}' does not exist`);\n    const subs = this.subs.get(name);\n    if (subs.has(subf)) subs.delete(subf);\n  }\n  _update() {\n    const fn = \"_update\";\n    m_ValidateActiveSeq(this);\n    this.lastOp = this.currentOp;\n    this.currentOp = this.ops[this.opIndex];\n  }\n  _notifyChange() {\n    const fn = \"_notifyChange\";\n    m_ValidateActiveSeq(this);\n    const subs = this.subs.get(this.currentOp._opName);\n    if (subs) subs.forEach((subf) => subf(this.currentOp, this.lastOp, this));\n  }\n  /* --- node utilities --- */\n  hasOp(opName) {\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    return this.ops.some((op) => op._opName === opName);\n  }\n  matchOp(opName) {\n    const fn = \"matchOp\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    if (!this.hasOp(opName)) throw Error(`${fn}: node '${opName}' does not exist`);\n    return opName === this.ops[this.opIndex]._opName;\n  }\n  /** remove all nodes and subscribers */\n  dispose() {\n    _OpSequencer.DeleteSequencer(this.seqName);\n  }\n  /* --- static utilities --- */\n  static GetSequencer(seqName) {\n    m_ValidateSeqName(seqName);\n    return OPSEQS.get(seqName);\n  }\n  static DeleteSequencer(seqName) {\n    const seq = _OpSequencer.GetSequencer(seqName);\n    seq.opsMap.clear();\n    seq.subs.forEach((subs) => subs.clear());\n    seq.ops.length = 0;\n    seq._disposed = true;\n    OPSEQS.delete(seqName);\n  }\n};\nvar class_op_seq_default = OpSequencer;\nvar VM_STATE = {};\nvar GROUPS = /* @__PURE__ */ new Map();\nvar USED_PROPS = /* @__PURE__ */ new Map();\nvar StateMgr = class _StateMgr {\n  // queued side effects\n  /// CONSTRUCTOR /////////////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  constructor(groupName) {\n    __publicField2(this, \"name\");\n    __publicField2(this, \"init\");\n    __publicField2(this, \"subs\");\n    __publicField2(this, \"queue\");\n    __publicField2(this, \"taps\");\n    __publicField2(this, \"effects\");\n    if (typeof groupName !== \"string\") throw Error(\"groupName must be a string\");\n    groupName = groupName.trim().toUpperCase();\n    if (GROUPS.has(groupName)) {\n      console.warn(\n        `(not an error) '${groupName}' construction duplicate, returning existing instance`\n      );\n      return GROUPS.get(groupName);\n    }\n    this.name = groupName;\n    this.init = false;\n    this.subs = /* @__PURE__ */ new Set();\n    this.queue = [];\n    this.taps = [];\n    this.effects = [];\n    VM_STATE[this.name] = {};\n    this.state = this.state.bind(this);\n    this.sendState = this.sendState.bind(this);\n    this.subscribeState = this.subscribeState.bind(this);\n    this.unsubscribeState = this.unsubscribeState.bind(this);\n    this.queueEffect = this.queueEffect.bind(this);\n    this._initializeState = this._initializeState.bind(this);\n    this._setState = this._setState.bind(this);\n    this._insertStateEvent = this._insertStateEvent.bind(this);\n    this._interceptState = this._interceptState.bind(this);\n    this._isValidState = this._isValidState.bind(this);\n    this._mergeState = this._mergeState.bind(this);\n    this._notifySubs = this._notifySubs.bind(this);\n    this._enqueue = this._enqueue.bind(this);\n    this._dequeue = this._dequeue.bind(this);\n    this._doEffect = this._doEffect.bind(this);\n    GROUPS.set(this.name, this);\n  }\n  /// MAIN CLASS METHODS //////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Return a COPY of the current clonedEvent */\n  state(key) {\n    const state = this._derefProps({ ...VM_STATE[this.name] });\n    if (typeof key === \"string\" && key.length > 0) return state[key];\n    return state;\n  }\n  /** Handle a clonedEvent update from a subscribing module. The incoming\n   *  vmstateEvent is checked against the master state object to ensure it\n   *  contains valid keys. Any filter functions are allowed to mutate a copy of\n   *  the incoming state event.\n   *  @param {object} vmStateEvent - object with group-specific props\n   */\n  sendState(vmStateEvent, callback) {\n    if (this._isValidState(vmStateEvent)) {\n      const clonedEvent = this._cloneStateObject(vmStateEvent);\n      this.taps.forEach((tap) => tap(clonedEvent));\n      const action = { stateEvent: clonedEvent, callback };\n      this._enqueue(action);\n    } else throw Error(\"SendState: invalid vmState update received, got:\");\n  }\n  /** Subscribe to state. The subscriber function looks like:\n   *  ( vmStateEvent, currentState ) => void\n   */\n  subscribeState(subFunc) {\n    if (typeof subFunc !== \"function\") throw Error(\"subscriber must be function\");\n    if (this.subs.has(subFunc)) console.warn(\"duplicate subscriber function\");\n    this.subs.add(subFunc);\n  }\n  /** Unsubscribe state */\n  unsubscribeState(subFunc) {\n    if (!this.subs.delete(subFunc))\n      console.warn(\"function not subscribed for\", this.name);\n  }\n  /** When executing a side effect from a component, use this method to\n   *  hold it until after all state updates have completed, so the DOM\n   *  is stable\n   */\n  queueEffect(effectFunc) {\n    if (typeof effectFunc !== \"function\") throw Error(\"effect must be a function\");\n    this.effects.push(effectFunc);\n    this._doEffect();\n  }\n  /// CLASS HELPER METHODS ////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Set the state object directly. used to initialize the state from within\n   *  an appcore module. skips state validation because the VM_STATE entry\n   *  is an empty object\n   */\n  _initializeState(stateObj) {\n    if (this.init)\n      throw Error(`_initializeState: store '${this.name}' already initialized`);\n    Object.keys(stateObj).forEach((k) => {\n      if (k.toLowerCase() !== k)\n        throw Error(`_initializeState: props must be lowercase, not '${k}'`);\n      if (stateObj[k] === void 0)\n        throw Error(\n          `_initializeState: prop '${k}' value can't be undefined (use null instead)`\n        );\n    });\n    if (VM_STATE[this.name]) {\n      Object.keys(stateObj).forEach((k) => {\n        if (k === \"_group\") return;\n        const assTo = USED_PROPS.get(k);\n        if (assTo !== void 0) throw Error(`${k} already assigned to ${assTo}`);\n        USED_PROPS.set(k, this.name);\n      });\n      VM_STATE[this.name] = stateObj;\n      this.init = true;\n    } else throw Error(`${this.name} does't exist in VM_STATE`);\n  }\n  /** In some cases, we want to update state but not trigger subscribers\n   *  related to it. Alias for _mergeState()\n   */\n  _setState(vmState) {\n    this._mergeState(vmState);\n  }\n  /** When SendState() is invoked, give the instance manager a change to\n   *  inspect the incoming state and do a side-effect and/or a filter.\n   *  They will run in order of interceptor registration\n   *  @param {function} tapFunc - receive stateEvent to mutate or act-on\n   */\n  _interceptState(tapFunc) {\n    if (typeof tapFunc !== \"function\") throw Error(`'${tapFunc}' is not a function`);\n    this.taps.push(tapFunc);\n  }\n  /** Allow synthesis of a state event by adding to queue without\n   *  immediately executing it. For use by _interceptState only.\n   *  Creates an action { stateObj, callback }\n   */\n  _insertStateEvent(stateEvent, callback) {\n    this._enqueue({ stateEvent, callback });\n  }\n  /** Return true if the event object conforms to expectations (see below) */\n  _isValidState(stateObj) {\n    const curState = VM_STATE[this.name];\n    let keysOk = true;\n    Object.keys(stateObj).forEach((k) => {\n      const keyTest = keysOk && curState[k] !== void 0;\n      if (keyTest === false) console.warn(`isValidState: '${k}' not a valid key`);\n      keysOk = keysOk && keyTest;\n    });\n    return keysOk;\n  }\n  /** Scan the object properties for arrays, and mutate with a new array.\n   *  In the case of an array containing references, the references will still\n   *  be the same but the array itself will be different\n   */\n  _derefProps(stateObj) {\n    Object.keys(stateObj).forEach((k) => {\n      if (Array.isArray(stateObj[k])) stateObj[k] = [...stateObj[k]];\n    });\n    return stateObj;\n  }\n  /** Utility method to clone state event. It handles array cloning as well but\n   *  is otherwise a shallow clone\n   */\n  _cloneStateObject(stateObj) {\n    const clone = this._derefProps({ ...stateObj });\n    return clone;\n  }\n  /** Take a clonedEvent event object and update the VM_STATE entry with\n   *  its property values. This creates an entirely new state object\n   */\n  _mergeState(stateObj) {\n    if (!this._isValidState(stateObj)) return void 0;\n    const newState = this._derefProps({\n      ...VM_STATE[this.name],\n      ...stateObj\n    });\n    VM_STATE[this.name] = newState;\n    return newState;\n  }\n  /** Forward the event to everyone. The vmStateEvent object contains\n   *  properties that changed only, appending a 'stateGroup' identifier\n   *  that tells you who sent it. Sends a read-only copy.\n   */\n  _notifySubs(stateObj) {\n    setTimeout(() => {\n      const subs = [...this.subs.values()];\n      stateObj.stateGroup = this.name;\n      const currentState = this._derefProps({ ...VM_STATE[this.name] });\n      subs.forEach((sub) => sub(stateObj, currentState));\n    });\n  }\n  /** Placeholder queueing system that doesn't do much now.\n   *  An action is { vmStateEvent, callback }\n   */\n  _enqueue(action) {\n    const { stateEvent, callback } = action;\n    if (!this._isValidState(stateEvent)) {\n      console.warn(\"bad vmStateEvent\", stateEvent);\n      return;\n    }\n    if (callback && typeof callback !== \"function\") {\n      console.warn(\"call must be function, not\", typeof callback, callback);\n      return;\n    }\n    this.queue.push(action);\n    this._dequeue();\n  }\n  /** Placeholder dequeing system that doesn't do much now.\n   *  An action is { vmStateEvent, callback }\n   */\n  _dequeue() {\n    const callbacks = [];\n    let action = this.queue.shift();\n    while (action !== void 0) {\n      const { vmStateEvent, callback } = action;\n      this._mergeState(vmStateEvent);\n      this._notifySubs(vmStateEvent);\n      if (typeof callback === \"function\") callbacks.push(callback);\n      action = this.queue.shift();\n    }\n    callbacks.forEach((f) => f());\n    this._doEffect();\n  }\n  /** execute effect functions that have been queued, generally if there\n   *  are no pending state changes\n   */\n  _doEffect() {\n    if (this.queue.length > 0) return;\n    setTimeout(() => {\n      let effect = this.effects.shift();\n      while (effect !== void 0) {\n        effect();\n        effect = this.effects.shift();\n      }\n    });\n  }\n  /// STATIC METHODS //////////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Return a state manager instance if it exists, undefined if not. Throws\n   *  errors if there are issues with the name */\n  static GetStateManager(groupName) {\n    if (typeof groupName !== \"string\") throw Error(`${groupName} is not a string`);\n    const bucket = groupName.trim().toUpperCase();\n    if (bucket !== groupName)\n      throw Error(`groupNames should be all uppercase, not ${bucket}`);\n    return GROUPS[bucket];\n  }\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** return a locked copy of the state of a particular named state group.\n   *  Unlike GetStateManager, this returns just the data object.\n   */\n  static GetStateData(groupName) {\n    if (typeof groupName !== \"string\") throw Error(`${groupName} is not a string`);\n    const bucket = groupName.trim().toUpperCase();\n    if (bucket !== groupName)\n      throw Error(`groupNames should be all uppercase, not ${bucket}`);\n    const state = VM_STATE[bucket];\n    if (!state) throw Error(`stateGroup ${bucket} is not defined`);\n    const readOnlyState = { ...state };\n    for (const prop of Object.keys(readOnlyState)) {\n      Object.defineProperty(readOnlyState, prop, {\n        writable: false\n      });\n    }\n    return readOnlyState;\n  }\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** return a Stage Manager instance. This just hides the new operator that\n   *  purposefully always returns an instance of an existing group if it\n   *  already exists\n   */\n  static GetInstance(groupName) {\n    return new _StateMgr(groupName);\n  }\n};\nvar class_state_mgr_default = StateMgr;\nvar urnet_browser_exports = {};\n__export2(urnet_browser_exports, {\n  Connect: () => Connect,\n  Disconnect: () => Disconnect,\n  EX_Start: () => EX_Start,\n  RegisterMessages: () => RegisterMessages\n});\nvar VALID_MSG_CHANNELS = [\"NET\", \"SRV\", \"LOCAL\", \"\"];\nvar VALID_PKT_TYPES = [\n  \"ping\",\n  \"signal\",\n  \"send\",\n  \"call\",\n  \"_auth\",\n  // special packet\n  \"_reg\",\n  // special packet\n  \"_decl\"\n  // special packet\n];\nvar SKIP_SELF_PKT_TYPES = [\"call\", \"send\"];\nvar VALID_ADDR_PREFIX = [\"???\", \"UR_\", \"WSS\", \"UDS\", \"MQT\", \"SRV\"];\nvar UADDR_DIGITS = 3;\nvar USED_ADDRS = /* @__PURE__ */ new Set();\nvar zeroPad = `0`.padStart(UADDR_DIGITS, \"0\");\nvar UADDR_NONE = `???${zeroPad}`;\nfunction IsValidType(msg_type) {\n  return VALID_PKT_TYPES.includes(msg_type);\n}\nfunction SkipOriginType(msg_type) {\n  return SKIP_SELF_PKT_TYPES.includes(msg_type);\n}\nfunction IsValidChannel(msg_chan) {\n  return VALID_MSG_CHANNELS.includes(msg_chan);\n}\nfunction IsValidAddress(addr) {\n  if (typeof addr !== \"string\") return false;\n  let prelen = 0;\n  if (!VALID_ADDR_PREFIX.some((pre) => {\n    prelen = pre.length;\n    return addr.startsWith(pre);\n  }))\n    return false;\n  const num = parseInt(addr.slice(prelen));\n  if (isNaN(num)) return false;\n  return true;\n}\nfunction IsValidMessage(msg) {\n  try {\n    return DecodeMessage(msg);\n  } catch (err) {\n    console.log(err.message);\n    console.log(err.stack.split(\"\\n\").slice(1).join(\"\\n\").trim());\n    return void 0;\n  }\n}\nvar ADDR_MAX_ID = 0;\nfunction AllocateAddress(opt) {\n  const fn = \"AllocateAddress\";\n  let addr = opt == null ? void 0 : opt.addr;\n  let pre = (opt == null ? void 0 : opt.prefix) || \"UA\";\n  if (addr === void 0) {\n    let id = ++ADDR_MAX_ID;\n    let padId = `${id}`.padStart(UADDR_DIGITS, \"0\");\n    addr = `${pre}${padId}`;\n  } else if (USED_ADDRS.has(addr)) {\n    throw Error(`${fn} - address ${addr} already allocated`);\n  }\n  USED_ADDRS.add(addr);\n  return addr;\n}\nfunction DecodeMessage(msg) {\n  if (typeof msg !== \"string\") throw Error(`message must be string: ${msg}`);\n  if (msg !== msg.toUpperCase()) throw Error(`message must be uppercase: ${msg}`);\n  const bits = msg.split(\":\");\n  if (bits.length === 0) throw Error(`invalid empty message`);\n  if (bits.length > 2) throw Error(`invalid channel:message format ${msg}`);\n  let [chan, name] = bits;\n  if (bits.length === 1) {\n    name = chan;\n    chan = \"LOCAL\";\n  }\n  if (chan === \"\") chan = \"LOCAL\";\n  if (!IsValidChannel(chan))\n    throw Error(`prefix must be ${VALID_MSG_CHANNELS.join(\" \").trim()} not ${chan}`);\n  return [chan, name];\n}\nfunction NormalizeMessage(msg) {\n  let [chan, name] = DecodeMessage(msg);\n  if (chan === \"LOCAL\") chan = \"\";\n  return `${chan}:${name}`;\n}\nfunction NormalizeData(data) {\n  if (Array.isArray(data) && data.length == 1) return data[0];\n  return data;\n}\nfunction IsLocalMessage(msg) {\n  const [chan] = DecodeMessage(msg);\n  return chan === \"LOCAL\";\n}\nfunction IsNetMessage(msg) {\n  const [chan] = DecodeMessage(msg);\n  return chan === \"NET\" || chan === \"SRV\";\n}\nfunction GetPacketHashString(pkt) {\n  return `${pkt.src_addr}:${pkt.id}`;\n}\nvar PR = typeof process !== \"undefined\" ? \"Packet\".padEnd(13) : \"Packet:\";\nvar LOG = (...args) => console.log(PR, ...args);\nvar NetPacket = class {\n  // returned error message\n  constructor(msg, data) {\n    __publicField2(this, \"id\");\n    __publicField2(this, \"msg_type\");\n    __publicField2(this, \"msg\");\n    __publicField2(this, \"data\");\n    __publicField2(this, \"auth\");\n    __publicField2(this, \"src_addr\");\n    __publicField2(this, \"hop_seq\");\n    __publicField2(this, \"hop_log\");\n    __publicField2(this, \"hop_dir\");\n    __publicField2(this, \"hop_rsvp\");\n    __publicField2(this, \"err\");\n    this.id = void 0;\n    this.src_addr = void 0;\n    this.hop_rsvp = false;\n    this.hop_seq = [];\n    this.hop_log = [];\n    this.auth = void 0;\n    this.err = void 0;\n    if (data !== void 0) this.data = data;\n    if (typeof msg === \"string\") {\n      if (!IsValidMessage(msg)) throw Error(`invalid msg format: ${msg}`);\n      this.msg = msg;\n    }\n  }\n  /** after creating a new packet, use setMeta() to assign id and envelope\n   *  meta used for routing and return packets\n   */\n  setMeta(msg_type, opt) {\n    if (!IsValidType(msg_type)) throw Error(`invalid msg_type: ${msg_type}`);\n    this.msg_type = msg_type;\n    this.hop_dir = (opt == null ? void 0 : opt.dir) || \"req\";\n    this.hop_rsvp = (opt == null ? void 0 : opt.rsvp) || false;\n  }\n  /** add hop to the hop sequence */\n  addHop(hop) {\n    if (!IsValidAddress(hop)) throw Error(`invalid hop: ${hop}`);\n    this.hop_seq.push(hop);\n  }\n  /** utility setters w/ checks - - - - - - - - - - - - - - - - - - - - - - **/\n  /** manually set the source address, with check */\n  setSrcAddr(s_addr) {\n    if (!IsValidAddress(s_addr)) throw Error(`invalid src_addr: ${s_addr}`);\n    if (this.hop_seq.length > 0 && this.hop_seq[0] !== s_addr)\n      throw Error(`src_addr ${s_addr} != ${this.hop_seq[0]}`);\n    this.src_addr = s_addr;\n    return this;\n  }\n  /** manually set direction */\n  setDir(dir) {\n    if (dir !== \"req\" && dir !== \"res\") throw Error(`invalid dir: ${dir}`);\n    this.hop_dir = dir;\n    return this;\n  }\n  /** set the authorization token */\n  setAuth(auth) {\n    if (typeof auth !== \"string\") {\n      LOG(\"setAuth: invalid auth\", auth);\n      throw Error(`invalid auth: ${auth}`);\n    }\n    this.auth = auth;\n    return this;\n  }\n  /** set message and data */\n  setMsgData(msg, data) {\n    this.setMsg(msg);\n    this.setData(data);\n    return this;\n  }\n  /** set message */\n  setMsg(msg) {\n    this.msg = msg;\n    return this;\n  }\n  /** set data */\n  setData(data) {\n    this.data = data;\n    return this;\n  }\n  /** merge data */\n  mergeData(data) {\n    this.data = { ...this.data, ...data };\n    return this;\n  }\n  /** packet reconstruction - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** make a packet from existing JSON */\n  setFromJSON(json) {\n    if (typeof json !== \"string\")\n      throw Error(`invalid json: ${json}, is ${typeof json}`);\n    return this.deserialize(json);\n  }\n  /** make a packet from existing object */\n  setFromObject(pktObj) {\n    const fn = \"setFromObject\";\n    if (typeof pktObj !== \"object\")\n      throw Error(`invalid pktObj: ${pktObj}, is ${typeof pktObj}`);\n    this.id = pktObj.id;\n    this.msg = pktObj.msg;\n    if (pktObj.data === void 0)\n      LOG(fn, `... pktObj${pktObj.id} .data is undefined`);\n    this.data = pktObj.data;\n    this.src_addr = pktObj.src_addr;\n    this.hop_log = pktObj.hop_log;\n    this.msg_type = pktObj.msg_type;\n    this.hop_seq = pktObj.hop_seq;\n    this.hop_dir = pktObj.hop_dir;\n    this.hop_rsvp = pktObj.hop_rsvp;\n    this.err = pktObj.err;\n    this.auth = pktObj.auth;\n    return this;\n  }\n  /** packet transport  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** rsvp required? */\n  hasRsvp() {\n    return this.hop_rsvp;\n  }\n  lastHop() {\n    return this.hop_seq[this.hop_seq.length - 1];\n  }\n  hasAuth() {\n    return this.auth !== void 0;\n  }\n  /** types that begin with _ are protocol messages that bypass dispatchPacket() */\n  isSpecialPkt() {\n    return this.msg_type.startsWith(\"_\");\n  }\n  /** authorization packets are the first packet sent on a client connection to\n   *  the message gateway server. They must not have a src_addr aassigned, using\n   *  the special UADDR_NONE value instead.\n   */\n  isBadAuthPkt() {\n    let error = \"\";\n    let a = this.msg_type === \"_auth\";\n    let b = this.msg === \"SRV:AUTH\";\n    let c = this.src_addr === UADDR_NONE;\n    if (!a) error += `msg_type ${this.msg_type} not _auth. `;\n    if (!b) error += `msg ${this.msg} not SRV:AUTH. `;\n    if (!c) error += `src_addr ${this.src_addr} not ${UADDR_NONE} `;\n    if (error.length > 0) return `isBadAuthPkt: ${error}`;\n    return void 0;\n  }\n  /** registration packets are sent on a client connection after\n   *  authentication. They must have a src_addr assigned, which was returned\n   *  by the server in the response to the auth packet, and this must match\n   *  the server's stored uaddr for the client connection.\n   */\n  isBadRegPkt(socket) {\n    let error = \"\";\n    let a = this.msg_type === \"_reg\";\n    let b = this.msg === \"SRV:REG\";\n    let c = this.src_addr === socket.uaddr;\n    if (!a) error += `msg_type ${this.msg_type} not _reg. `;\n    if (!b) error += `msg ${this.msg} not SRV:REG. `;\n    if (!c) error += `src_addr ${this.src_addr} not ${socket.uaddr}. `;\n    if (error.length > 0) return `isBadRegPkt: ${error}`;\n    return void 0;\n  }\n  authenticate(socket) {\n    const { msg, src_addr, hop_dir, hop_seq } = this;\n    if (!this.isResponse()) LOG(PR, `would auth ${src_addr} '${msg}'`);\n    return true;\n  }\n  isRequest() {\n    return this.hop_dir === \"req\";\n  }\n  isResponse() {\n    return this.hop_dir === \"res\";\n  }\n  /** serialization - - - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  serialize() {\n    return JSON.stringify(this);\n  }\n  deserialize(data) {\n    try {\n      let obj = JSON.parse(data);\n      return this.setFromObject(obj);\n    } catch (err) {\n      LOG(\"NetPacket.deserialize failed\", data);\n    }\n  }\n  /** information utilities - - - - - - - - - - - - - - - - - - - - - - - - **/\n  isValidType(type) {\n    return IsValidType(type);\n  }\n  isValidMessage(msg) {\n    return IsValidMessage(msg) !== void 0;\n  }\n  decodeMessage(msg) {\n    return DecodeMessage(msg);\n  }\n  /** debugging - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** add error string to packet error */\n  error(msg) {\n    if (!this.err) this.err = \"\";\n    this.err += msg;\n    return msg;\n  }\n  /** manually add a transport-related message eto the hog log. this is not\n   *  the same as hop_seq which is used to track the routing of the packet.\n   */\n  hopLog(msg) {\n    const info = `${this.id} ${this.hop_dir}`;\n    this.hop_log.push(`${info}: ${msg}`);\n    return msg;\n  }\n};\nvar class_urnet_packet_default = NetPacket;\nvar PR2 = typeof process !== \"undefined\" ? \"EndPoint\".padEnd(13) : \"EndPoint\".padEnd(11);\nvar LOG2 = console.log.bind(console);\nvar AGE_INTERVAL = 1e3;\nvar AGE_MAX = 60 * 30;\nvar NetEndpoint = class {\n  // client registration status\n  constructor() {\n    __publicField2(this, \"handled_msgs\");\n    __publicField2(this, \"uaddr\");\n    __publicField2(this, \"client_socks\");\n    __publicField2(this, \"remoted_msgs\");\n    __publicField2(this, \"transactions\");\n    __publicField2(this, \"cli_counter\");\n    __publicField2(this, \"pkt_counter\");\n    __publicField2(this, \"cli_gateway\");\n    __publicField2(this, \"cli_sck_timer\");\n    __publicField2(this, \"cli_ident\");\n    __publicField2(this, \"cli_auth\");\n    __publicField2(this, \"cli_reg\");\n    this.uaddr = void 0;\n    this.cli_ident = void 0;\n    this.cli_auth = void 0;\n    this.cli_reg = void 0;\n    this.cli_gateway = void 0;\n    this.client_socks = void 0;\n    this.remoted_msgs = void 0;\n    this.handled_msgs = /* @__PURE__ */ new Map();\n    this.transactions = /* @__PURE__ */ new Map();\n    this.pkt_counter = 0;\n    this.cli_counter = 0;\n    this.cli_sck_timer = null;\n  }\n  /** API: initialize this endpoint's client server, providing a hardcoded\n   *  server UADDR that is distinct from those used by client pools\n   */\n  configAsServer(srv_addr) {\n    const fn = \"configAsServer:\";\n    if (!IsValidAddress(srv_addr)) throw Error(`${fn} invalid srv_addr ${srv_addr}`);\n    if (this.uaddr && this.uaddr !== srv_addr) {\n      let err = `${fn} uaddr ${this.uaddr} already set.`;\n      throw Error(err);\n    }\n    this.uaddr = srv_addr;\n    if (this.client_socks !== void 0)\n      LOG2(PR2, this.uaddr, `already configured`, [...this.client_socks.keys()]);\n    this.client_socks = /* @__PURE__ */ new Map();\n    if (this.remoted_msgs !== void 0)\n      LOG2(PR2, this.uaddr, `already configured`, [...this.remoted_msgs.keys()]);\n    this.remoted_msgs = /* @__PURE__ */ new Map();\n    this.addMessageHandler(\"SRV:REFLECT\", (data) => {\n      data.info = `built-in service`;\n      return data;\n    });\n  }\n  /** API: Server data event handler for incoming data from a client connection.\n   *  This is the mirror to _ingestServerPacket() function used by client endpoints.\n   *  This is the entry point for incoming data from clients */\n  _ingestClientPacket(jsonData, socket) {\n    let pkt = this.newPacket().deserialize(jsonData);\n    let retPkt;\n    retPkt = this._handleAuthRequest(pkt, socket);\n    if (retPkt) return retPkt;\n    retPkt = this._handleRegRequest(pkt, socket);\n    if (retPkt) return retPkt;\n    retPkt = this._handleDeclRequest(pkt, socket);\n    if (retPkt) return retPkt;\n    this.dispatchPacket(pkt);\n  }\n  /** API: when a client connects to this endpoint, register it as a socket and\n   *  allocate a uaddr for it */\n  addClient(socket) {\n    const fn = \"addClient:\";\n    if (typeof socket !== \"object\") throw Error(`${fn} invalid socket`);\n    if (socket.uaddr !== void 0) throw Error(`${fn} socket already added`);\n    const new_uaddr = AllocateAddress({ prefix: \"UR_\" });\n    socket.uaddr = new_uaddr;\n    socket.age = 0;\n    socket.auth = void 0;\n    socket.msglist = void 0;\n    this.client_socks.set(new_uaddr, socket);\n    return new_uaddr;\n  }\n  /** API: when a client disconnects from this endpoint, delete its socket and\n   *  remove all message forwarding */\n  removeClient(uaddr_obj) {\n    const fn = \"removeClient:\";\n    let uaddr = typeof uaddr_obj === \"string\" ? uaddr_obj : uaddr_obj.uaddr;\n    if (typeof uaddr !== \"string\") {\n      LOG2(PR2, `${fn} invalid uaddr ${typeof uaddr}`);\n      return void 0;\n    }\n    if (!this.client_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    this._deleteRemoteMessagesForAddress(uaddr);\n    this.client_socks.delete(uaddr);\n    return uaddr;\n  }\n  /** API: given a uaddr, return the socket */\n  getClient(uaddr) {\n    const fn = \"getClient:\";\n    if (this.client_socks === void 0) return void 0;\n    return this.client_socks.get(uaddr);\n  }\n  /** API: start a timer to check for dead sockets */\n  enableClientAging(activate) {\n    const fn = \"enableClientAging:\";\n    if (activate) {\n      if (this.cli_sck_timer) clearInterval(this.cli_sck_timer);\n      this.cli_sck_timer = setInterval(() => {\n        this.client_socks.forEach((socket, uaddr) => {\n          socket.age += AGE_INTERVAL;\n          if (socket.age > AGE_MAX) {\n            LOG2(PR2, this.uaddr, `socket ${uaddr} expired`);\n          }\n        });\n      }, AGE_INTERVAL);\n      return;\n    }\n    if (this.cli_sck_timer) clearInterval(this.cli_sck_timer);\n    this.cli_sck_timer = null;\n    LOG2(PR2, this.uaddr, `timer stopped`);\n  }\n  /** support: handle auth packet if the session.auth is not defined */\n  _handleAuthRequest(pkt, socket) {\n    if (!socket.authenticated()) {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.uaddr);\n      const error = pkt.isBadAuthPkt();\n      if (error) {\n        console.error(PR2, error);\n        pkt.data = { error };\n        return pkt;\n      }\n      const { identity, secret } = pkt.data;\n      if (identity) {\n        socket.auth = identity;\n        pkt.data = { uaddr: socket.uaddr, cli_auth: \"ServerProvidedAuthToken\" };\n      } else {\n        pkt.data = { error: \"invalid identity\" };\n      }\n      return pkt;\n    }\n    return void 0;\n  }\n  /** support: handle registration packet */\n  _handleRegRequest(pkt, socket) {\n    if (!pkt.isBadRegPkt(socket)) {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.uaddr);\n      if (pkt.msg !== \"SRV:REG\") {\n        pkt.data = { error: `invalid reg packet ${pkt.msg}` };\n        return pkt;\n      }\n      if (pkt.src_addr !== socket.uaddr) {\n        LOG2(PR2, \"src address mismatch\", pkt.src_addr, \"!= sock\", socket.uaddr);\n        pkt.data = { error: \"address mismatch\" };\n        return pkt;\n      }\n      const { name, type } = pkt.data;\n      if (name) {\n        const { uaddr } = socket;\n        pkt.data = { ok: true, status: `registered name:${name} type:${type}` };\n        return pkt;\n      }\n      pkt.data = { error: \"registration failed\" };\n      return pkt;\n    }\n    return void 0;\n  }\n  /** support: handle client dynamic definitions */\n  _handleDeclRequest(pkt, socket) {\n    if (pkt.msg_type === \"_decl\") {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.uaddr);\n      if (pkt.msg !== \"SRV:DEF\") {\n        console.log(\"invalid def packet\", pkt.msg);\n        pkt.data = { error: `invalid def packet ${pkt.msg}` };\n        return pkt;\n      }\n      pkt.data.status = [];\n      const { msg_list } = pkt.data;\n      const { uaddr } = socket;\n      if (Array.isArray(msg_list)) {\n        this.registerRemoteMessagesToAddress(uaddr, msg_list);\n        pkt.data.status.push(`registered ${msg_list.length} messages`);\n      }\n      if (pkt.data.status.length === 0) {\n        pkt.data = { error: \"no definitions\" };\n        return pkt;\n      }\n    }\n    return void 0;\n  }\n  /** client connection handshaking - - - - - - - - - - - - - - - - - - - - **/\n  /** API: client endpoints need to have an \"address\" assigned to them,\n   *  otherwise the endpoint will not work */\n  async connectAsClient(gateway, auth) {\n    const fn = \"connectAsClient:\";\n    if (gateway && typeof gateway.send === \"function\") {\n      this.cli_gateway = gateway;\n    } else throw Error(`${fn} invalid gateway`);\n    if (auth) {\n      const pkt = this.newAuthPacket(auth);\n      const { msg } = pkt;\n      let authData = await this._queueTransaction(pkt, gateway);\n      const { uaddr, cli_auth, error } = authData;\n      if (error) {\n        LOG2(PR2, `${fn} error:`, error);\n        return false;\n      }\n      if (!IsValidAddress(uaddr)) throw Error(`${fn} invalid uaddr ${uaddr}`);\n      this.uaddr = uaddr;\n      if (cli_auth === void 0) throw Error(`${fn} invalid cli_auth`);\n      this.cli_auth = cli_auth;\n      LOG2(PR2, \"AUTHENTICATED\", uaddr, cli_auth);\n      this.cli_auth = cli_auth;\n      return authData;\n    }\n    throw Error(`${fn} arg must be identity`);\n  }\n  /** API: Client data event handler for incoming data from the gateway. This is\n   *  the mirror to _ingestClientPacket() function that is used by servers. This\n   *  is entry point for incoming data from server\n   */\n  _ingestServerPacket(jsonData, socket) {\n    const fn = \"_ingestServerPacket:\";\n    const pkt = this.newPacket().deserialize(jsonData);\n    if (this.cli_gateway) {\n      if (this._handleAuthResponse(pkt)) return;\n      if (this._handleRegResponse(pkt)) return;\n      if (this._handleDeclResponse(pkt)) return;\n    }\n    this.dispatchPacket(pkt);\n  }\n  /** API: register client with client endpoint info */\n  async declareClientProperties(info) {\n    const fn = \"declareClientProperties:\";\n    if (!this.cli_gateway) throw Error(`${fn} no gateway`);\n    const pkt = this.newRegPacket();\n    pkt.data = { ...info };\n    let regData = await this._queueTransaction(pkt, this.cli_gateway);\n    const { ok, status, error } = regData;\n    if (error) {\n      LOG2(PR2, `${fn} error:`, error);\n      return regData;\n    }\n    if (ok) {\n      LOG2(PR2, \"REGISTERED\", status);\n      this.cli_reg = info;\n      return regData;\n    }\n    throw Error(`${fn} unexpected response`, regData);\n  }\n  /** API: declare client messages */\n  async declareClientMessages() {\n    const fn = \"declareClientMessages:\";\n    const msg_list = this.getNetMessageNames();\n    const response = await this._declareClientServices({ msg_list });\n    const { msg_list: rmsg_list, error } = response;\n    if (error) {\n      LOG2(PR2, `${fn} error:`, error);\n    } else {\n      LOG2(PR2, `DECLARED ${rmsg_list.length} messages`);\n      rmsg_list.forEach((msg) => LOG2(PR2, `  '${msg}'`));\n    }\n    return response;\n  }\n  /** support: handle authentication response packet directly rather than through\n   *  the netcall interface in dispatchPacket() */\n  _handleAuthResponse(pkt) {\n    const fn = \"_handleAuthResponse:\";\n    if (pkt.msg_type !== \"_auth\") return false;\n    if (pkt.hop_dir !== \"res\") return false;\n    this.resolveTransaction(pkt);\n    return true;\n  }\n  /** support: handle registration response packet directly rather than through\n   *  the netcall interface in dispatchPacket() */\n  _handleRegResponse(pkt) {\n    const fn = \"_handleRegResponse:\";\n    if (pkt.msg_type !== \"_reg\") return false;\n    if (pkt.hop_dir !== \"res\") return false;\n    if (pkt.src_addr !== this.uaddr) throw Error(`${fn} misaddressed packet???`);\n    this.resolveTransaction(pkt);\n    return true;\n  }\n  /** support: handle declaration packet */\n  _handleDeclResponse(pkt) {\n    const fn = \"_handleDeclResponse:\";\n    if (pkt.msg_type !== \"_decl\") return false;\n    if (pkt.hop_dir !== \"res\") return false;\n    if (pkt.src_addr !== this.uaddr) throw Error(`${fn} misaddressed packet???`);\n    this.resolveTransaction(pkt);\n    return true;\n  }\n  /** message declaration and invocation - - - - - - - - - - - - - - - - - -**/\n  /** API: declare a message handler for a given message */\n  addMessageHandler(msg, handler) {\n    const fn = \"addMessageHandler:\";\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    if (msg !== msg.toUpperCase()) throw Error(`${fn} msg must be uppercase`);\n    if (typeof handler !== \"function\") throw Error(`${fn} invalid handler`);\n    const key = NormalizeMessage(msg);\n    if (!this.handled_msgs.has(key))\n      this.handled_msgs.set(key, /* @__PURE__ */ new Set());\n    const handler_set = this.handled_msgs.get(key);\n    handler_set.add(handler);\n  }\n  /** API: remove a previously declared message handler for a given message */\n  deleteMessageHandler(msg, handler) {\n    const fn = \"deleteMessageHandler:\";\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    if (typeof handler !== \"function\") throw Error(`${fn} invalid handler`);\n    const key = NormalizeMessage(msg);\n    const handler_set = this.handled_msgs.get(key);\n    if (!handler_set) throw Error(`${fn} unexpected empty set '${key}'`);\n    handler_set.delete(handler);\n  }\n  /** API: call local message registered on this endPoint only */\n  async call(msg, data) {\n    const fn = \"call:\";\n    if (!IsLocalMessage(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getMessageHandlers(msg);\n    const promises = [];\n    handlers.forEach((handler) => {\n      promises.push(\n        new Promise((resolve, reject) => {\n          try {\n            resolve(handler({ ...data }));\n          } catch (err) {\n            reject(err);\n          }\n        })\n      );\n    });\n    if (promises.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    const resData = await Promise.all(promises);\n    return resData;\n  }\n  /** API: send local message registered on this endPoint only, returning no data */\n  async send(msg, data) {\n    const fn = \"send:\";\n    if (!IsLocalMessage(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getMessageHandlers(msg);\n    if (handlers.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    handlers.forEach((handler) => {\n      handler({ ...data });\n    });\n    return Promise.resolve(true);\n  }\n  /** API: signal local message registered on this endPoint only, returning no data.\n   */\n  signal(msg, data) {\n    const fn = \"signal:\";\n    if (!IsLocalMessage(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getMessageHandlers(msg);\n    if (handlers.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    handlers.forEach((handler) => {\n      handler({ ...data });\n    });\n  }\n  /** API: ping local message, return with number of handlers */\n  async ping(msg) {\n    const fn = \"ping:\";\n    if (!IsLocalMessage(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getMessageHandlers(msg);\n    return Promise.resolve(handlers.length);\n  }\n  /** API: call net message, resolves when packet returns from server with data */\n  async netCall(msg, data) {\n    const fn = \"netCall:\";\n    if (!IsNetMessage(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg, data);\n    pkt.setMeta(\"call\", {\n      dir: \"req\",\n      rsvp: true\n    });\n    let resData = await new Promise((resolve, reject) => {\n      const meta = { msg, uaddr: this.uaddr };\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.initialSend(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    return resData;\n  }\n  /** API: send net message, returning promise that will resolve when the server has\n   *  received and processed/forwarded the message */\n  async netSend(msg, data) {\n    const fn = \"netSend:\";\n    if (!IsNetMessage(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg, data);\n    pkt.setMeta(\"send\", {\n      dir: \"req\",\n      rsvp: true\n    });\n    let resData = await new Promise((resolve, reject) => {\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.uaddr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.initialSend(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    return resData;\n  }\n  /** API: signal net message, returning void (not promise)\n   *  used for the idea of 'raising signals' as opposed to 'sending data'. It\n   *  resolves immediately when the signal is sent, and does not check with the\n   *  server  */\n  netSignal(msg, data) {\n    const fn = \"netSignal:\";\n    if (!IsNetMessage(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg, data);\n    pkt.setMeta(\"signal\", {\n      dir: \"req\",\n      rsvp: false\n    });\n    this.initialSend(pkt);\n  }\n  /** API: returns with a list of uaddr from the server which is the uaddr of the\n   *  all clients that have registered for the message */\n  async netPing(msg) {\n    const fn = \"netPing:\";\n    if (!IsNetMessage(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg);\n    pkt.setMeta(\"ping\", {\n      dir: \"req\",\n      rsvp: true\n    });\n    let resData = await new Promise((resolve, reject) => {\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.uaddr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.initialSend(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    return resData;\n  }\n  /** packet utilities  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** declare client attributes is a generic declaration packet that can contain\n   *  any number of attributes that the client wants to declare to the server.\n   *  for example, see declareClientMessages() */\n  async _declareClientServices(def) {\n    const fn = \"_declareClientServices:\";\n    if (!this.cli_gateway) throw Error(`${fn} no gateway`);\n    const pkt = this.newDeclPacket();\n    pkt.data = { ...def };\n    const { msg } = pkt;\n    let declared = await this._queueTransaction(pkt, this.cli_gateway);\n    const { error, status } = declared;\n    if (error) {\n      LOG2(PR2, `${fn} error:`, error);\n      return declared;\n    }\n    if (status) return declared;\n    throw Error(`${fn} unexpected response`, declared);\n  }\n  /** shuts down the gateway to server, forcing close\n   *  Chrome 125.0.6422.77 doesn't seem to send a close frame on reload\n   *  Firefox 126.0 doesn't fire beforeunload\n   */\n  disconnectAsClient() {\n    if (this.cli_gateway === void 0) return;\n    if (typeof this.cli_gateway.close === \"function\") {\n      this.cli_gateway.close();\n    }\n    this.cli_gateway = void 0;\n  }\n  /** endpoint lookup tables - - - - - - - - - - - - - - - - - - - -  - - - **/\n  /** return true if the message is handled anywhere */\n  packetHasHandler(pkt) {\n    const fn = \"messageHasHandler:\";\n    const a = this.getMessageHandlers(pkt.msg).length > 0;\n    const b = this.isServer() && this.getMessageAddresses(pkt.msg).length > 0;\n    return a || b;\n  }\n  /** get list of messages allocated to a uaddr */\n  getMessagesForAddress(uaddr) {\n    const fn = \"getMessagesForAddress:\";\n    if (!this.isServer()) return [];\n    if (typeof uaddr !== \"string\") throw Error(`${fn} invalid uaddr`);\n    if (!this.client_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    const msg_list = [];\n    this.remoted_msgs.forEach((addr_set, msg) => {\n      if (addr_set.has(uaddr)) msg_list.push(msg);\n    });\n    return msg_list;\n  }\n  /** get list of UADDRs that a message is forwarded to */\n  getMessageAddresses(msg) {\n    const fn = \"getMessageAddresses:\";\n    if (!this.isServer()) return [];\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    const key = NormalizeMessage(msg);\n    if (!this.remoted_msgs.has(key))\n      this.remoted_msgs.set(key, /* @__PURE__ */ new Set());\n    const addr_set = this.remoted_msgs.get(key);\n    const addr_list = Array.from(addr_set);\n    return addr_list;\n  }\n  /** return list of local handlers for given message */\n  getMessageHandlers(msg) {\n    const fn = \"getMessageHandlers:\";\n    if (this.handled_msgs === void 0) return [];\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    const key = NormalizeMessage(msg);\n    if (!this.handled_msgs.has(key))\n      this.handled_msgs.set(key, /* @__PURE__ */ new Set());\n    const handler_set = this.handled_msgs.get(key);\n    if (!handler_set) throw Error(`${fn} unexpected empty set '${key}'`);\n    const handler_list = Array.from(handler_set);\n    return handler_list;\n  }\n  /** informational routing information - - - - - - - - - - - - - - - - - - **/\n  /** return handler list for this endpoint */\n  getMessageNames() {\n    const list = [];\n    this.handled_msgs.forEach((handler_set, key) => {\n      list.push(key);\n    });\n    return list;\n  }\n  /** return only net messages */\n  getNetMessageNames() {\n    const list = [];\n    this.handled_msgs.forEach((handler_set, key) => {\n      if (IsNetMessage(key)) list.push(key);\n    });\n    return list;\n  }\n  /** return list of active transactions for this endpoint */\n  getPendingTransactions() {\n    const fn = \"getPendingTransactions:\";\n    const list = [];\n    this.transactions.forEach((transaction, hash) => {\n      const { msg, uaddr } = transaction;\n      list.push({ hash, msg, uaddr });\n    });\n    return list;\n  }\n  /** server endpoints manage list of messages in clients  - - - - -  - - - **/\n  /** register a message handler for a given message to passed uaddr */\n  registerRemoteMessagesToAddress(uaddr, msgList) {\n    const fn = \"registerRemoteMessagesToAddress:\";\n    if (typeof uaddr !== \"string\") throw Error(`${fn} invalid uaddr`);\n    if (!this.client_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    msgList.forEach((msg) => {\n      if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n      if (msg !== msg.toUpperCase()) throw Error(`${fn} msg must be uppercase`);\n      const key = NormalizeMessage(msg);\n      if (!this.remoted_msgs.has(key))\n        this.remoted_msgs.set(key, /* @__PURE__ */ new Set());\n      const msg_set = this.remoted_msgs.get(key);\n      msg_set.add(uaddr);\n    });\n  }\n  /** unregister message handlers for a given message to passed uaddr */\n  _deleteRemoteMessagesForAddress(uaddr) {\n    const fn = \"_deleteRemoteMessagesForAddress:\";\n    if (typeof uaddr !== \"string\") throw Error(`${fn} invalid uaddr`);\n    if (!this.client_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    const removed = [];\n    this.remoted_msgs.forEach((msg_set, key) => {\n      if (msg_set.has(uaddr)) removed.push(key);\n      msg_set.delete(uaddr);\n    });\n    return removed;\n  }\n  /** packet interface  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** Receive a single packet from the wire, and determine what to do with it.\n   *  It's assumed that _ingestClientPacket() has already handled\n   *  authentication for clients before this method is received.\n   *  The packet has several possible processing options!\n   *  - packet is response to an outgoing transaction\n   *  - packet is a message that we handle\n   *  - packet is a message that we forward\n   *  - packet is unknown message so we return it with error\n   *  If the packet has the rsvp flag set, we need to return\n   *  it to the source address in the packet with any data\n   */\n  async dispatchPacket(pkt) {\n    const fn = \"dispatchPacket:\";\n    if (pkt.isResponse()) {\n      if (pkt.src_addr === this.uaddr) {\n        this.resolveTransaction(pkt);\n      } else {\n        this.returnToSender(pkt);\n      }\n      return;\n    }\n    if (!pkt.isRequest()) {\n      LOG2(PR2, this.uaddr, fn, `invalid packet`, pkt);\n      return;\n    }\n    if (pkt.msg_type === \"ping\") {\n      const pingArr = this.getMessageAddresses(pkt.msg);\n      const pingHandlers = this.getMessageHandlers(pkt.msg);\n      if (pingHandlers.length > 0) pingArr.push(this.uaddr);\n      pkt.setData(pingArr);\n      this.returnToSender(pkt);\n      return;\n    }\n    if (pkt.msg_type === \"signal\") {\n      await this.awaitHandlers(pkt);\n      if (this.isServer()) await this.awaitRemoteHandlers(pkt);\n      return;\n    }\n    let retData;\n    if (this.packetHasHandler(pkt)) {\n      retData = await this.awaitHandlers(pkt);\n      if (this.isServer()) retData = await this.awaitRemoteHandlers(pkt);\n    } else {\n      LOG2(PR2, this.uaddr, fn, `unknown message`, pkt);\n      retData = { error: `unknown message '${pkt.msg}'` };\n    }\n    if (!pkt.hasRsvp()) return;\n    if (pkt.msg_type === \"call\") {\n      pkt.data = NormalizeData(retData);\n    } else if (pkt.msg_type === \"send\") {\n      pkt.data = true;\n    }\n    this.returnToSender(pkt);\n  }\n  /** Start a transaction, which returns promises to await. This method\n   *  is a queue that uses Promises to wait for the return, which is\n   *  triggered by a returning packet in dispatchPacket(pkt).\n   */\n  async awaitRemoteHandlers(pkt) {\n    const fn = \"awaitRemoteHandlers:\";\n    if (pkt.hop_dir !== \"req\") throw Error(`${fn} packet is not a request`);\n    const { gateway, clients } = this.getRoutingInformation(pkt);\n    const promises = [];\n    if (gateway) {\n      const p = this.awaitTransaction(pkt, gateway);\n      if (p) promises.push(p);\n    }\n    if (Array.isArray(clients)) {\n      clients.forEach((sock) => {\n        const p = this.awaitTransaction(pkt, sock);\n        if (p) promises.push(p);\n      });\n    }\n    let data = await Promise.all(promises);\n    return data;\n  }\n  /** Start a handler call, which might have multiple implementors.\n   *  Returns data from all handlers as an array or a single item\n   */\n  async awaitHandlers(pkt) {\n    const fn = \"awaitHandlers:\";\n    const { msg } = pkt;\n    const handlers = this.getMessageHandlers(msg);\n    if (handlers.length === 0) return Promise.resolve([]);\n    const promises = [];\n    handlers.forEach((handler) => {\n      promises.push(\n        new Promise((resolve, reject) => {\n          try {\n            resolve(handler({ ...pkt.data }));\n          } catch (err) {\n            reject(err);\n          }\n        })\n      );\n    });\n    let data = await Promise.all(promises);\n    return data;\n  }\n  /** Send a single packet on all available interfaces based on the\n   *  message. Use for initial outgoing packets only from the\n   *  netCall, netSend, netSignal, and netPing methods.\n   */\n  initialSend(pkt) {\n    const fn = \"initialSend:\";\n    if (pkt.src_addr === void 0) throw Error(`${fn}src_addr undefined`);\n    if (this.uaddr === void 0) throw Error(`${fn} uaddr undefined`);\n    if (pkt.hop_seq.length !== 0) throw Error(`${fn} pkt must have no hops yet`);\n    if (pkt.msg_type !== \"ping\" && pkt.data === void 0)\n      throw Error(`${fn} data undefined`);\n    const { gateway, clients } = this.getRoutingInformation(pkt);\n    pkt.addHop(this.uaddr);\n    if (gateway) {\n      if (this.cli_reg === void 0) throw Error(`${fn} endpoint not registered`);\n      gateway.send(pkt);\n    }\n    if (Array.isArray(clients)) {\n      clients.forEach((sock) => sock.send(pkt));\n    }\n  }\n  /** Used to forward a transaction from server to a remote client\n   */\n  awaitTransaction(pkt, sock) {\n    const clone = this.clonePacket(pkt);\n    clone.id = this.assignPacketId(clone);\n    if (pkt.src_addr === sock.uaddr && SkipOriginType(pkt.msg_type)) return;\n    return this._queueTransaction(clone, sock);\n  }\n  /** Used to resolve a forwarded transaction received by server from\n   *  a remote client\n   */\n  resolveTransaction(pkt) {\n    const fn = \"resolveTransaction:\";\n    if (pkt.hop_rsvp !== true) throw Error(`${fn} packet is not RSVP`);\n    if (pkt.hop_dir !== \"res\") throw Error(`${fn} packet is not a response`);\n    if (pkt.hop_seq.length < 2 && !pkt.isSpecialPkt())\n      throw Error(`${fn} packet has no hops`);\n    this._dequeueTransaction(pkt);\n  }\n  /** utility method for conducting transactions */\n  _queueTransaction(pkt, sock) {\n    const fn = \"_queueTransaction:\";\n    const hash = GetPacketHashString(pkt);\n    if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n    const { src_addr } = pkt;\n    const { uaddr: dst_addr } = sock;\n    return new Promise((resolve, reject) => {\n      const meta = { msg: pkt.msg, uaddr: pkt.src_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      sock.send(pkt);\n    });\n  }\n  /** utility method for completing transactions */\n  _dequeueTransaction(pkt) {\n    const fn = \"_finishTransaction:\";\n    const hash = GetPacketHashString(pkt);\n    const resolver = this.transactions.get(hash);\n    if (!resolver) throw Error(`${fn} no resolver for hash ${hash}`);\n    const { resolve, reject } = resolver;\n    const { data } = pkt;\n    if (pkt.err) reject(pkt.err);\n    else resolve(data);\n    this.transactions.delete(hash);\n  }\n  /** Return a packet to its source address. If this endpoint is a server,\n   *  then it might have the socket stored. Otherwise, if this endpoint is\n   *  also a client of another server, pass the back through the gateway.\n   *  This is used by server endpoints to return packets to clients.\n   */\n  returnToSender(pkt) {\n    const fn = \"returnToSender:\";\n    if (pkt.hop_rsvp !== true) throw Error(`${fn} packet is not RSVP`);\n    if (pkt.hop_seq.length < 1) throw Error(`${fn} packet has no hops`);\n    pkt.setDir(\"res\");\n    pkt.addHop(this.uaddr);\n    const { gateway, src_addr } = this.getRoutingInformation(pkt);\n    if (this.isServer()) {\n      const socket = this.getClient(src_addr);\n      if (socket) socket.send(pkt);\n      return;\n    }\n    if (gateway) {\n      gateway.send(pkt);\n      return;\n    }\n    LOG2(PR2, `${fn} unroutable packet`, pkt);\n  }\n  /** return array of sockets to use for sending packet,\n   *  based on pkt.msg and pkt.src_addr\n   */\n  getRoutingInformation(pkt) {\n    const fn = \"getRoutingInformation:\";\n    const { msg, src_addr } = pkt;\n    if (!IsNetMessage(msg)) throw Error(`${fn} '${msg}' is invalid message`);\n    const gateway = this.cli_gateway;\n    const self_addr = this.uaddr;\n    const msg_list = this.getMessageAddresses(msg);\n    const clients = [];\n    msg_list.forEach((uaddr) => {\n      if (uaddr === this.uaddr) return;\n      const socket = this.getClient(uaddr);\n      if (socket) clients.push(socket);\n    });\n    return {\n      msg,\n      src_addr,\n      self_addr,\n      gateway,\n      clients\n    };\n  }\n  /** packet utility - - - - - - - - - - - - - - - - - - - - - - - - - - - -**/\n  assignPacketId(pkt) {\n    if (pkt.src_addr === void 0) pkt.src_addr = this.uaddr;\n    const count = ++this.pkt_counter;\n    pkt.id = `pkt[${pkt.src_addr}:${count}]`;\n    return pkt.id;\n  }\n  /** convert JSON to packet and return */\n  packetFromJSON(json) {\n    const pkt = new class_urnet_packet_default();\n    pkt.setFromJSON(json);\n    return pkt;\n  }\n  /** create a new packet with proper address */\n  newPacket(msg, data) {\n    const fn = \"newPacket:\";\n    const pkt = new class_urnet_packet_default(msg, data);\n    pkt.setSrcAddr(this.uaddr || UADDR_NONE);\n    if (this.cli_auth) pkt.setAuth(this.cli_auth);\n    pkt.id = this.assignPacketId(pkt);\n    return pkt;\n  }\n  /** clone a packet with new id */\n  clonePacket(pkt) {\n    const clone = this.newPacket(pkt.msg, pkt.data);\n    clone.setFromJSON(pkt.serialize());\n    clone.src_addr = this.uaddr;\n    clone.id = this.assignPacketId(clone);\n    return clone;\n  }\n  /** create an authentication packet, which is the first packet that must be sent\n   *  after connecting to the server */\n  newAuthPacket(authObj) {\n    const pkt = this.newPacket(\"SRV:AUTH\", { ...authObj });\n    pkt.setMeta(\"_auth\", { rsvp: true });\n    pkt.setSrcAddr(UADDR_NONE);\n    this.assignPacketId(pkt);\n    return pkt;\n  }\n  /** create a registration packet */\n  newRegPacket() {\n    const pkt = this.newPacket(\"SRV:REG\");\n    pkt.setMeta(\"_reg\", { rsvp: true });\n    return pkt;\n  }\n  /** create a declaration packet shell */\n  newDeclPacket() {\n    const pkt = this.newPacket(\"SRV:DEF\");\n    pkt.setMeta(\"_decl\", { rsvp: true });\n    return pkt;\n  }\n  /** environment utilities - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** return true if this endpoint is managing connections */\n  isServer() {\n    return this.client_socks !== void 0 && this.remoted_msgs !== void 0;\n  }\n  /** socket utilities  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** given a socket, see if it's already registered */\n  isNewSocket(socket) {\n    const fn = \"isNewSocket:\";\n    if (typeof socket !== \"object\") return false;\n    return socket.uaddr === void 0;\n  }\n  /** client endpoints need to have an authentication token to\n   *  access URNET beyond registration\n   */\n  authorizeSocket(auth) {\n    const fn = \"authorizeSocket:\";\n    LOG2(PR2, this.uaddr, \"would check auth token\");\n  }\n};\nvar class_urnet_endpoint_default = NetEndpoint;\nvar PR3 = typeof process !== \"undefined\" ? \"Socket\".padEnd(13) : \"Socket:\";\nvar NetSocket = class {\n  // name of the socket-ish object\n  constructor(connectObj, io) {\n    __publicField2(this, \"connector\");\n    __publicField2(this, \"sendFunc\");\n    __publicField2(this, \"closeFunc\");\n    __publicField2(this, \"onDataFunc\");\n    __publicField2(this, \"uaddr\");\n    __publicField2(this, \"auth\");\n    __publicField2(this, \"msglist\");\n    __publicField2(this, \"age\");\n    __publicField2(this, \"label\");\n    this.connector = connectObj;\n    const { send, onData, close } = io;\n    this.sendFunc = send.bind(connectObj);\n    this.closeFunc = close.bind(connectObj);\n    this.onDataFunc = onData.bind(connectObj);\n  }\n  send(pkt) {\n    this.sendFunc(pkt);\n  }\n  close() {\n    this.closeFunc();\n  }\n  getConnector() {\n    return this.connector;\n  }\n  authenticated() {\n    let a = this.auth !== void 0;\n    return a;\n  }\n};\nvar class_urnet_socket_default = NetSocket;\nvar PR4 = util_prompts_default.makeStyleFormatter(\"URNET\", \"TagPurple\");\nvar LOG3 = console.log.bind(console);\nvar DBG = false;\nvar TIMEOUT = 360;\nvar EP = new class_urnet_endpoint_default();\nvar SERVER_LINK;\nvar EP_UADDR = EP.uaddr;\nvar LISTENER_COUNT = 0;\nfunction m_Sleep(ms, resolve) {\n  return new Promise(\n    (localResolve) => setTimeout(() => {\n      if (typeof resolve === \"function\") resolve();\n      localResolve();\n    }, ms)\n  );\n}\nfunction m_DisconnectListener() {\n  EP.disconnectAsClient();\n}\nfunction Connect() {\n  const wss_url = \"/webplay-ws\";\n  const promiseConnect = new Promise((resolve) => {\n    SERVER_LINK = new WebSocket(wss_url);\n    SERVER_LINK.addEventListener(\"open\", async () => {\n      let out = `Connected to ${wss_url}`;\n      LOG3(...PR4(out));\n      const send = (pkt) => SERVER_LINK.send(pkt.serialize());\n      const onData = (event) => EP._ingestServerPacket(event.data, client_sock);\n      const close = () => SERVER_LINK.close();\n      const client_sock = new class_urnet_socket_default(SERVER_LINK, { send, onData, close });\n      SERVER_LINK.addEventListener(\"message\", onData);\n      SERVER_LINK.addEventListener(\"close\", () => {\n        out = `Server closed connection.`;\n        LOG3(...PR4(out));\n        EP.disconnectAsClient();\n      });\n      if (LISTENER_COUNT === 0) {\n        window.addEventListener(\"beforeunload\", m_DisconnectListener);\n        LISTENER_COUNT++;\n      }\n      const auth = { identity: \"my_voice_is_my_passport\", secret: \"crypty\" };\n      const resdata = await EP.connectAsClient(client_sock, auth);\n      if (DBG) LOG3(...PR4(\"EP.connectAsClient returned\", resdata));\n      if (resdata.error) {\n        console.error(resdata.error);\n        resolve(false);\n        return;\n      }\n      const info = { name: \"UDSClient\", type: \"client\" };\n      const regdata = await EP.declareClientProperties(info);\n      if (DBG) LOG3(...PR4(\"EP.declareClientProperties returned\", regdata));\n      if (regdata.error) {\n        console.error(regdata.error);\n        resolve(false);\n        return;\n      }\n      EP_UADDR = EP.uaddr;\n      resolve(true);\n    });\n  });\n  return promiseConnect;\n}\nasync function RegisterMessages() {\n  const resdata = await EP.declareClientMessages();\n  if (DBG) LOG3(...PR4(\"EP.declareClientMessages returned\", resdata));\n}\nfunction Disconnect(seconds = TIMEOUT) {\n  return new Promise((resolve, reject) => {\n    LOG3(...PR4(`waiting for ${seconds} seconds...`));\n    if (LISTENER_COUNT > 0) {\n      window.removeEventListener(\"beforeunload\", m_DisconnectListener);\n      LISTENER_COUNT--;\n    }\n    m_Sleep(seconds * 1e3, () => {\n      resolve(true);\n      SERVER_LINK.close();\n      let out = `Client closing connection.`;\n      LOG3(...PR4(out));\n    });\n  });\n}\nasync function EX_Start() {\n  await Connect();\n  EP.addMessageHandler(\"NET:HOT_RELOAD_APP\", (data) => {\n    LOG3(...PR4(`HOT_RELOAD_APP`));\n    window.location.reload();\n  });\n  await RegisterMessages();\n}\nvar lib_uid_exports = {};\n__export2(lib_uid_exports, {\n  DecodeID: () => DecodeID,\n  GetDefaultSchema: () => GetDefaultSchema,\n  IsValidFormat: () => IsValidFormat,\n  IsValidPrefix: () => IsValidPrefix,\n  IsValidSchema: () => IsValidSchema,\n  NewFullID: () => NewFullID,\n  NewID: () => NewID,\n  PrefixShortID: () => PrefixShortID,\n  SetDefaultSchema: () => SetDefaultSchema\n});\nvar SCHEMAS = {\n  \"meme\": {\n    \"n\": \"node\",\n    \"e\": \"edge\",\n    \"p\": \"project\"\n  }\n};\nvar DEFAULT_SCHEMA = \"\";\nvar ID_COUNTER = 0;\nfunction DecodeID(uid) {\n  if (!IsValidFormat(uid)) return [];\n  let bits = uid.split(\":\");\n  if (bits.length < 1 || bits.length > 2) return [];\n  if (bits.length === 1) bits.unshift(\"\");\n  const [schema, prefix] = bits;\n  bits = prefix.split(\"-\");\n  if (bits.length !== 2) return [];\n  return [schema, ...bits];\n}\nfunction NewID(prefix, int) {\n  const fn = \"ShortID:\";\n  if (int !== void 0) {\n    if (typeof int !== \"number\") throw new Error(`${fn} invalid id ${int}`);\n    if (int < 0) throw new Error(`${fn} negative id ${int}`);\n    if (int % 1 !== 0) throw new Error(`${fn} non-integer id ${int}`);\n  } else {\n    int = ID_COUNTER++;\n  }\n  const uid = `${prefix}-${int}`;\n  return uid;\n}\nfunction NewFullID(schema, prefix, int) {\n  const fn = \"EncodeID:\";\n  const shortUID = NewID(prefix, int);\n  if (!IsValidSchema(schema)) throw new Error(`${fn} unknown schema ${schema}`);\n  if (!IsValidPrefix(`${schema}:${prefix}`))\n    throw new Error(`${fn} unknown prefix ${prefix}`);\n  const uid = `${schema}:${prefix}-${int}`;\n  return uid;\n}\nfunction PrefixShortID(uid, prefix) {\n  const [_, id] = DecodeID(uid);\n  return NewID(prefix, parseInt(id));\n}\nfunction IsValidFormat(uid) {\n  const isLowerCase = uid === uid.toLowerCase();\n  const isFullForm = /^[\\w]+:[\\w]+-[\\d]+$/.test(uid);\n  const isShortForm = /^[\\w]+-[\\d]+$/.test(uid);\n  return isLowerCase && (isFullForm || isShortForm);\n}\nfunction IsValidSchema(schema) {\n  return Object.keys(SCHEMAS).includes(schema);\n}\nfunction IsValidPrefix(sch_pre) {\n  const fn = \"IsValidPrefix:\";\n  const bits = sch_pre.split(\":\");\n  if (bits.length > 2) throw new Error(`${fn} Invalid schema prefix ${sch_pre}`);\n  if (bits.length === 1) bits.unshift(\"\");\n  const [schema, prefix] = bits;\n  const isValidSchema = IsValidSchema(schema);\n  const isValidPrefix = Object.keys(SCHEMAS[schema]).includes(prefix);\n  return isValidSchema && isValidPrefix;\n}\nfunction SetDefaultSchema(schema) {\n  const fn = \"SetDefaultSchema:\";\n  if (!IsValidSchema(schema)) throw new Error(`${fn} Invalid schema ${schema}`);\n  DEFAULT_SCHEMA = schema;\n}\nfunction GetDefaultSchema() {\n  return DEFAULT_SCHEMA;\n}\nvar http_host = \"127.0.0.1\";\nvar http_port = 8080;\nvar wss_path = \"urnet-http\";\nvar HTTP_CLIENT_INFO = {\n  http_host,\n  http_port,\n  http_url: `http://${http_host}:${http_port}`,\n  //\n  wss_path,\n  wss_url: `ws://${http_host}:${http_port}/${wss_path}`\n};\nfunction GetClientInfoFromWindowLocation(winLocation) {\n  const { host, pathname, protocol } = winLocation;\n  const { http_port: http_port2, wss_path: wss_path2 } = HTTP_CLIENT_INFO;\n  const tls = protocol === \"https:\";\n  const hostpath = host + pathname;\n  const http_url = tls ? `https://${hostpath}` : `http://${hostpath}`;\n  const wss_url = tls ? `wss://${hostpath}/${wss_path2}` : `ws://${hostpath}${wss_path2}`;\n  let new_info = {\n    ...HTTP_CLIENT_INFO,\n    http_host: hostpath,\n    http_url,\n    wss_url\n  };\n  HTTP_CLIENT_INFO = new_info;\n  return new_info;\n}\nvar { makeStyleFormatter: makeStyleFormatter2 } = util_prompts_default;\nvar PR5 = makeStyleFormatter2(\"UR\", \"TagCyan\");\nvar CLASS = {\n  OpSequencer: class_op_seq_default,\n  StateMgr: class_state_mgr_default,\n  NetSocket: class_urnet_socket_default,\n  NetEndpoint: class_urnet_endpoint_default,\n  NetPacket: class_urnet_packet_default\n};\nvar LIB = {\n  UID: lib_uid_exports\n};\nvar CONSTANT = {\n  URNET: { ...HTTP_CLIENT_INFO, GetClientInfoFromWindowLocation }\n};\nfunction ClientTest() {\n  console.log(...PR5(\"System Integration of new URSYS module successful!\"));\n}\nvar export_TEXT = import_util_text.default;\n\n// _ur_addons/net/urnet-types.ts\nvar VALID_MSG_CHANNELS2 = [\"NET\", \"SRV\", \"LOCAL\", \"\"];\nvar VALID_PKT_TYPES2 = [\n  \"ping\",\n  \"signal\",\n  \"send\",\n  \"call\",\n  \"_auth\",\n  // special packet\n  \"_reg\",\n  // special packet\n  \"_decl\"\n  // special packet\n];\nvar VALID_ADDR_PREFIX2 = [\"???\", \"UR_\", \"WSS\", \"UDS\", \"MQT\", \"SRV\"];\nvar UADDR_DIGITS2 = 3;\nvar USED_ADDRS2 = /* @__PURE__ */ new Set();\nvar zeroPad2 = `0`.padStart(UADDR_DIGITS2, \"0\");\nvar UADDR_NONE2 = `???${zeroPad2}`;\nfunction IsValidType2(msg_type) {\n  return VALID_PKT_TYPES2.includes(msg_type);\n}\nfunction IsValidChannel2(msg_chan) {\n  return VALID_MSG_CHANNELS2.includes(msg_chan);\n}\nfunction IsValidAddress2(addr) {\n  if (typeof addr !== \"string\") return false;\n  let prelen = 0;\n  if (!VALID_ADDR_PREFIX2.some((pre) => {\n    prelen = pre.length;\n    return addr.startsWith(pre);\n  }))\n    return false;\n  const num = parseInt(addr.slice(prelen));\n  if (isNaN(num)) return false;\n  return true;\n}\nfunction IsValidMessage2(msg) {\n  try {\n    return DecodeMessage2(msg);\n  } catch (err) {\n    console.log(err.message);\n    console.log(err.stack.split(\"\\n\").slice(1).join(\"\\n\").trim());\n    return void 0;\n  }\n}\nvar ADDR_MAX_ID2 = 0;\nfunction AllocateAddress2(opt) {\n  const fn = \"AllocateAddress\";\n  let addr = opt == null ? void 0 : opt.addr;\n  let pre = (opt == null ? void 0 : opt.prefix) || \"UA\";\n  if (addr === void 0) {\n    let id = ++ADDR_MAX_ID2;\n    let padId = `${id}`.padStart(UADDR_DIGITS2, \"0\");\n    addr = `${pre}${padId}`;\n  } else if (USED_ADDRS2.has(addr)) {\n    throw Error(`${fn} - address ${addr} already allocated`);\n  }\n  USED_ADDRS2.add(addr);\n  return addr;\n}\nfunction DecodeMessage2(msg) {\n  if (typeof msg !== \"string\") throw Error(`message must be string: ${msg}`);\n  if (msg !== msg.toUpperCase()) throw Error(`message must be uppercase: ${msg}`);\n  const bits = msg.split(\":\");\n  if (bits.length === 0) throw Error(`invalid empty message`);\n  if (bits.length > 2) throw Error(`invalid channel:message format ${msg}`);\n  let [chan, name] = bits;\n  if (bits.length === 1) {\n    name = chan;\n    chan = \"LOCAL\";\n  }\n  if (chan === \"\") chan = \"LOCAL\";\n  if (!IsValidChannel2(chan))\n    throw Error(`prefix must be ${VALID_MSG_CHANNELS2.join(\" \").trim()} not ${chan}`);\n  return [chan, name];\n}\nfunction NormalizeMessage2(msg) {\n  let [chan, name] = DecodeMessage2(msg);\n  if (chan === \"LOCAL\") chan = \"\";\n  return `${chan}:${name}`;\n}\nfunction NormalizeData2(data) {\n  if (Array.isArray(data) && data.length == 1) return data[0];\n  return data;\n}\nfunction IsLocalMessage2(msg) {\n  const [chan] = DecodeMessage2(msg);\n  return chan === \"LOCAL\";\n}\nfunction IsNetMessage2(msg) {\n  const [chan] = DecodeMessage2(msg);\n  return chan === \"NET\" || chan === \"SRV\";\n}\nfunction GetPacketHashString2(pkt) {\n  return `${pkt.src_addr}:${pkt.id}`;\n}\n\n// _ur_addons/net/class-urnet-packet.ts\nvar PR6 = typeof process !== \"undefined\" ? \"Packet\".padEnd(13) : \"Packet:\";\nvar LOG4 = (...args) => console.log(PR6, ...args);\nvar NetPacket2 = class {\n  // returned error message\n  constructor(msg, data) {\n    __publicField(this, \"id\");\n    // network-wide unique id for this packet\n    __publicField(this, \"msg_type\");\n    // ping, signal, send, call\n    __publicField(this, \"msg\");\n    // name of the URNET message\n    __publicField(this, \"data\");\n    // payload of the URNET message\n    __publicField(this, \"auth\");\n    // authentication token\n    __publicField(this, \"src_addr\");\n    // URNET address of the sender\n    __publicField(this, \"hop_seq\");\n    // URNET addresses that have seen this packet\n    __publicField(this, \"hop_log\");\n    // log of debug messages by hop\n    __publicField(this, \"hop_dir\");\n    // direction of the packet 'req' or 'res'\n    __publicField(this, \"hop_rsvp\");\n    // whether the packet is a response to a request\n    __publicField(this, \"err\");\n    this.id = void 0;\n    this.src_addr = void 0;\n    this.hop_rsvp = false;\n    this.hop_seq = [];\n    this.hop_log = [];\n    this.auth = void 0;\n    this.err = void 0;\n    if (data !== void 0) this.data = data;\n    if (typeof msg === \"string\") {\n      if (!IsValidMessage2(msg)) throw Error(`invalid msg format: ${msg}`);\n      this.msg = msg;\n    }\n  }\n  /** after creating a new packet, use setMeta() to assign id and envelope\n   *  meta used for routing and return packets\n   */\n  setMeta(msg_type, opt) {\n    if (!IsValidType2(msg_type)) throw Error(`invalid msg_type: ${msg_type}`);\n    this.msg_type = msg_type;\n    this.hop_dir = (opt == null ? void 0 : opt.dir) || \"req\";\n    this.hop_rsvp = (opt == null ? void 0 : opt.rsvp) || false;\n  }\n  /** add hop to the hop sequence */\n  addHop(hop) {\n    if (!IsValidAddress2(hop)) throw Error(`invalid hop: ${hop}`);\n    this.hop_seq.push(hop);\n  }\n  /** utility setters w/ checks - - - - - - - - - - - - - - - - - - - - - - **/\n  /** manually set the source address, with check */\n  setSrcAddr(s_addr) {\n    if (!IsValidAddress2(s_addr)) throw Error(`invalid src_addr: ${s_addr}`);\n    if (this.hop_seq.length > 0 && this.hop_seq[0] !== s_addr)\n      throw Error(`src_addr ${s_addr} != ${this.hop_seq[0]}`);\n    this.src_addr = s_addr;\n    return this;\n  }\n  /** manually set direction */\n  setDir(dir) {\n    if (dir !== \"req\" && dir !== \"res\") throw Error(`invalid dir: ${dir}`);\n    this.hop_dir = dir;\n    return this;\n  }\n  /** set the authorization token */\n  setAuth(auth) {\n    if (typeof auth !== \"string\") {\n      LOG4(\"setAuth: invalid auth\", auth);\n      throw Error(`invalid auth: ${auth}`);\n    }\n    this.auth = auth;\n    return this;\n  }\n  /** set message and data */\n  setMsgData(msg, data) {\n    this.setMsg(msg);\n    this.setData(data);\n    return this;\n  }\n  /** set message */\n  setMsg(msg) {\n    this.msg = msg;\n    return this;\n  }\n  /** set data */\n  setData(data) {\n    this.data = data;\n    return this;\n  }\n  /** merge data */\n  mergeData(data) {\n    this.data = { ...this.data, ...data };\n    return this;\n  }\n  /** packet reconstruction - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** make a packet from existing JSON */\n  setFromJSON(json) {\n    if (typeof json !== \"string\")\n      throw Error(`invalid json: ${json}, is ${typeof json}`);\n    return this.deserialize(json);\n  }\n  /** make a packet from existing object */\n  setFromObject(pktObj) {\n    const fn = \"setFromObject\";\n    if (typeof pktObj !== \"object\")\n      throw Error(`invalid pktObj: ${pktObj}, is ${typeof pktObj}`);\n    this.id = pktObj.id;\n    this.msg = pktObj.msg;\n    if (pktObj.data === void 0)\n      LOG4(fn, `... pktObj${pktObj.id} .data is undefined`);\n    this.data = pktObj.data;\n    this.src_addr = pktObj.src_addr;\n    this.hop_log = pktObj.hop_log;\n    this.msg_type = pktObj.msg_type;\n    this.hop_seq = pktObj.hop_seq;\n    this.hop_dir = pktObj.hop_dir;\n    this.hop_rsvp = pktObj.hop_rsvp;\n    this.err = pktObj.err;\n    this.auth = pktObj.auth;\n    return this;\n  }\n  /** packet transport  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** rsvp required? */\n  isRsvp() {\n    return this.hop_rsvp;\n  }\n  lastHop() {\n    return this.hop_seq[this.hop_seq.length - 1];\n  }\n  /** types that begin with _ are protocol messages that bypass pktReceive() */\n  isProtocol() {\n    return this.msg_type.startsWith(\"_\");\n  }\n  isRequest() {\n    return this.hop_dir === \"req\";\n  }\n  isResponse() {\n    return this.hop_dir === \"res\";\n  }\n  /** serialization - - - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  serialize() {\n    return JSON.stringify(this);\n  }\n  deserialize(data) {\n    try {\n      let obj = JSON.parse(data);\n      return this.setFromObject(obj);\n    } catch (err) {\n      LOG4(\"NetPacket.deserialize failed\", data);\n    }\n  }\n  /** information utilities - - - - - - - - - - - - - - - - - - - - - - - - **/\n  isValidType(type) {\n    return IsValidType2(type);\n  }\n  isValidMessage(msg) {\n    return IsValidMessage2(msg) !== void 0;\n  }\n  decodeMessage(msg) {\n    return DecodeMessage2(msg);\n  }\n  /** debugging - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** add error string to packet error */\n  error(msg) {\n    if (!this.err) this.err = \"\";\n    this.err += msg;\n    return msg;\n  }\n  /** manually add a transport-related message eto the hog log. this is not\n   *  the same as hop_seq which is used to track the routing of the packet.\n   */\n  hopLog(msg) {\n    const info = `${this.id} ${this.hop_dir}`;\n    this.hop_log.push(`${info}: ${msg}`);\n    return msg;\n  }\n};\n\n// _ur_addons/net/class-urnet-endpoint.ts\nvar DBG2 = false;\nvar PR7 = typeof process !== \"undefined\" ? \"EndPoint\".padEnd(13) : \"EndPoint:\";\nvar LOG5 = (...args) => DBG2 && console.log(PR7, ...args);\nvar AGE_INTERVAL2 = 1e3;\nvar AGE_MAX2 = 60 * 30;\nfunction _PKT(ep, fn, text, pkt) {\n  let { id, msg, msg_type } = pkt;\n  if (id === void 0 && msg_type === \"_reg\") id = `pkt[${UADDR_NONE2}:0]`;\n  let out = `${ep.urnet_addr} ${text} '${msg}' `.padEnd(40, \"~\");\n  out += ` ${id.padEnd(12)} ${fn}`;\n  return out;\n}\nvar NetEndpoint2 = class {\n  // client registration status\n  constructor() {\n    __publicField(this, \"urnet_addr\");\n    // the address for this endpoint\n    //\n    __publicField(this, \"cli_gateway\");\n    // gateway to server\n    __publicField(this, \"srv_socks\");\n    // uaddr->I_NetSocket\n    __publicField(this, \"srv_msgs\");\n    // msg->uaddr[]\n    __publicField(this, \"msg_handlers\");\n    // msg->handlers[]\n    __publicField(this, \"transactions\");\n    // hash->resolver\n    //\n    __publicField(this, \"cli_counter\");\n    // counter for generating unique uaddr\n    __publicField(this, \"pkt_counter\");\n    // counter for generating packet ids\n    //\n    __publicField(this, \"cli_sck_timer\");\n    // timer for checking socket age\n    __publicField(this, \"cli_ident\");\n    // client credentials to request authentication\n    __publicField(this, \"cli_auth\");\n    // client access token for\n    __publicField(this, \"cli_reg\");\n    this.urnet_addr = void 0;\n    this.cli_ident = void 0;\n    this.cli_auth = void 0;\n    this.cli_reg = void 0;\n    this.cli_gateway = void 0;\n    this.srv_socks = void 0;\n    this.srv_msgs = void 0;\n    this.msg_handlers = /* @__PURE__ */ new Map();\n    this.transactions = /* @__PURE__ */ new Map();\n    this.pkt_counter = 0;\n    this.cli_counter = 0;\n    this.cli_sck_timer = null;\n  }\n  /** client connection management  - - - - - - - - - - - - - - - - - - - - **/\n  /** return true if this endpoint is managing connections */\n  configAsServer(srv_addr) {\n    const fn = \"configAsServer:\";\n    if (!IsValidAddress2(srv_addr)) throw Error(`${fn} invalid srv_addr ${srv_addr}`);\n    if (this.urnet_addr && this.urnet_addr !== srv_addr) {\n      let err = `${fn} urnet_addr ${this.urnet_addr} already set.`;\n      err += `currently, `;\n      throw Error(err);\n    }\n    this.urnet_addr = srv_addr;\n    if (this.srv_socks !== void 0)\n      LOG5(this.urnet_addr, `already configured`, [...this.srv_socks.keys()]);\n    this.srv_socks = /* @__PURE__ */ new Map();\n    if (this.srv_msgs !== void 0)\n      LOG5(this.urnet_addr, `already configured`, [...this.srv_msgs.keys()]);\n    this.srv_msgs = /* @__PURE__ */ new Map();\n    this.registerMessage(\"SRV:REFLECT\", (data) => {\n      return { memo: \"defaults defined in Endpoint.configAsServer\" };\n    });\n  }\n  /** return true if this endpoint is managing connections */\n  isServer() {\n    return this.srv_socks !== void 0 && this.srv_msgs !== void 0;\n  }\n  /** socket utilities  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** given a socket, see if it's already registered */\n  isNewSocket(socket) {\n    const fn = \"isNewSocket:\";\n    if (typeof socket !== \"object\") return false;\n    return socket.uaddr === void 0;\n  }\n  /** client endpoints need to have an authentication token to\n   *  access URNET beyond registration\n   */\n  authorizeSocket(auth) {\n    const fn = \"authorizeSocket:\";\n    LOG5(this.urnet_addr, \"would check auth token\");\n  }\n  /** return true if this socket passes authentication status */\n  isAuthorizedSocket(socket) {\n    const fn = \"authorizeSocket:\";\n    LOG5(fn, \"would check JWT in socket.auth\");\n    LOG5(this.urnet_addr, \"would check JWT in socket.auth\");\n    if (!socket.auth) return false;\n    return true;\n  }\n  /** endpoint client management  - - - - - - - - - - - - - - - - - - - - - **/\n  /** Server data event handler for incoming data from a client connection.\n   *  This is the mirror to _serverDataIngest() function used by client endpoints.\n   * This is the entry point for incoming data from clients */\n  _clientDataIngest(jsonData, socket) {\n    let pkt = this.newPacket().deserialize(jsonData);\n    let retPkt;\n    retPkt = this.handleClientAuth(pkt, socket);\n    if (retPkt) return retPkt;\n    retPkt = this.handleClientReg(pkt, socket);\n    if (retPkt) return retPkt;\n    retPkt = this.handleClientDeclare(pkt, socket);\n    if (retPkt) return retPkt;\n    if (pkt.auth) {\n      LOG5(\".. would check authentication token\");\n      this.pktReceive(pkt);\n      return;\n    }\n    pkt.setDir(\"res\");\n    pkt.addHop(this.urnet_addr);\n    pkt.data = { error: \"unauthorized packet rejected\" };\n    return pkt;\n  }\n  /** handle auth packet */\n  handleClientAuth(pkt, socket) {\n    if (socket.auth === void 0) {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.urnet_addr);\n      if (pkt.msg_type === \"_auth\") {\n        if (pkt.msg !== \"SRV:AUTH\") {\n          pkt.data = { error: `invalid auth packet ${pkt.msg}` };\n          return pkt;\n        }\n      }\n      const { identity } = pkt.data;\n      if (identity) {\n        socket.auth = identity;\n        pkt.data = { uaddr: socket.uaddr, cli_auth: \"AnAuthToken\" };\n      } else {\n        pkt.data = { error: \"invalid identity\" };\n      }\n      return pkt;\n    }\n    return void 0;\n  }\n  /** handle registration packet */\n  handleClientReg(pkt, socket) {\n    if (pkt.msg_type === \"_reg\") {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.urnet_addr);\n      if (pkt.msg !== \"SRV:REG\") {\n        pkt.data = { error: `invalid reg packet ${pkt.msg}` };\n        return pkt;\n      }\n      if (pkt.src_addr !== socket.uaddr) {\n        LOG5(\"src address mismatch\", pkt.src_addr, \"!= sock\", socket.uaddr);\n        pkt.data = { error: \"address mismatch\" };\n        return pkt;\n      }\n      const { name, type } = pkt.data;\n      if (name) {\n        const { uaddr } = socket;\n        pkt.data = { ok: true, status: `registered name:${name} type:${type}` };\n        return pkt;\n      }\n      pkt.data = { error: \"registration failed\" };\n      return pkt;\n    }\n    return void 0;\n  }\n  /** handle client dynamic definitions */\n  handleClientDeclare(pkt, socket) {\n    if (pkt.msg_type === \"_decl\") {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.urnet_addr);\n      if (pkt.msg !== \"SRV:DEF\") {\n        pkt.data = { error: `invalid def packet ${pkt.msg}` };\n        return pkt;\n      }\n      pkt.data.status = [];\n      const { msg_list } = pkt.data;\n      const { uaddr } = socket;\n      if (Array.isArray(msg_list)) {\n        this.registerRemoteMessages(uaddr, msg_list);\n        pkt.data.status.push(`registered ${msg_list.length} messages`);\n      }\n      if (pkt.data.status.length === 0) {\n        pkt.data = { error: \"no definitions\" };\n        return pkt;\n      }\n    }\n    return void 0;\n  }\n  /** when a client connects to this endpoint, register it as a socket and\n   *  allocate a uaddr for it */\n  addClient(socket) {\n    const fn = \"addClient:\";\n    if (typeof socket !== \"object\") throw Error(`${fn} invalid socket`);\n    if (socket.uaddr !== void 0) throw Error(`${fn} socket already added`);\n    const new_uaddr = AllocateAddress2({ prefix: \"UR_\" });\n    socket.uaddr = new_uaddr;\n    socket.age = 0;\n    socket.auth = void 0;\n    socket.msglist = void 0;\n    this.srv_socks.set(new_uaddr, socket);\n    return new_uaddr;\n  }\n  /** given a uaddr, return the socket */\n  getClient(uaddr) {\n    const fn = \"getClient:\";\n    if (this.srv_socks === void 0) return void 0;\n    return this.srv_socks.get(uaddr);\n  }\n  /** when a client disconnects from this endpoint, delete its socket and\n   *  remove all message forwarding */\n  removeClient(uaddr_obj) {\n    const fn = \"removeClient:\";\n    let uaddr = typeof uaddr_obj === \"string\" ? uaddr_obj : uaddr_obj.uaddr;\n    if (typeof uaddr !== \"string\") {\n      LOG5(`${fn} invalid uaddr ${typeof uaddr}`);\n      return void 0;\n    }\n    if (!this.srv_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    this._delRemoteMessages(uaddr);\n    this.srv_socks.delete(uaddr);\n    return uaddr;\n  }\n  /** start a timer to check for dead sockets */\n  enableClientAging(activate) {\n    const fn = \"enableClientAging:\";\n    if (activate) {\n      if (this.cli_sck_timer) clearInterval(this.cli_sck_timer);\n      this.cli_sck_timer = setInterval(() => {\n        this.srv_socks.forEach((socket, uaddr) => {\n          socket.age += AGE_INTERVAL2;\n          if (socket.age > AGE_MAX2) {\n            if (DBG2) LOG5(this.urnet_addr, `socket ${uaddr} expired`);\n          }\n        });\n      }, AGE_INTERVAL2);\n      return;\n    }\n    if (this.cli_sck_timer) clearInterval(this.cli_sck_timer);\n    this.cli_sck_timer = null;\n    if (DBG2) LOG5(this.urnet_addr, `timer stopped`);\n  }\n  /** client connection handshaking - - - - - - - - - - - - - - - - - - - - **/\n  /** Client data event handler for incoming data from the gateway.\n   *  This is the mirror to _clientDataIngest() function that is used by servers.\n   *  This is entry point for incoming data from server */\n  _serverDataIngest(jsonData, socket) {\n    const fn = \"_serverDataIngest:\";\n    const pkt = this.newPacket().deserialize(jsonData);\n    if (this.cli_gateway) {\n      if (this.handleAuthResponse(pkt)) return;\n      if (this.handleRegResponse(pkt)) return;\n    }\n    this.pktReceive(pkt);\n  }\n  /** client endpoints need to have an \"address\" assigned to them, otherwise\n   *  the endpoint will not work */\n  async connectAsClient(gateway, auth) {\n    const fn = \"connectAsClient:\";\n    if (gateway && typeof gateway.send === \"function\") {\n      this.cli_gateway = gateway;\n    } else throw Error(`${fn} invalid gateway`);\n    if (auth) {\n      const pkt = this.newAuthPacket(auth);\n      const { msg } = pkt;\n      const requestAuth = new Promise((resolve, reject) => {\n        const hash = GetPacketHashString2(pkt);\n        if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n        const meta = { msg, uaddr: this.urnet_addr };\n        this.transactions.set(hash, { resolve, reject, ...meta });\n        try {\n          this.cli_gateway.send(pkt);\n        } catch (err) {\n          reject(err);\n        }\n      });\n      let authData = await requestAuth;\n      const { uaddr, cli_auth, error } = authData;\n      if (error) {\n        LOG5(`${fn} error:`, error);\n        return false;\n      }\n      if (!IsValidAddress2(uaddr)) throw Error(`${fn} invalid uaddr ${uaddr}`);\n      this.urnet_addr = uaddr;\n      if (cli_auth === void 0) throw Error(`${fn} invalid cli_auth`);\n      this.cli_auth = cli_auth;\n      LOG5(\"** AUTHENTICATED **\", uaddr, cli_auth);\n      this.cli_auth = cli_auth;\n      return authData;\n    }\n    throw Error(`${fn} arg must be identity`);\n  }\n  /** create a authentication packet, which is the first packet that must be sent\n   *  after connecting to the server */\n  newAuthPacket(authObj) {\n    const pkt = this.newPacket(\"SRV:AUTH\", { ...authObj });\n    pkt.setMeta(\"_auth\", { rsvp: true });\n    pkt.setSrcAddr(UADDR_NONE2);\n    this.assignPacketId(pkt);\n    return pkt;\n  }\n  /** handle authentication response packet directly rather than through\n   *  the netcall interface in pktReceive() */\n  handleAuthResponse(pkt) {\n    const fn = \"handleAuthResponse:\";\n    if (pkt.msg_type !== \"_auth\") return false;\n    if (pkt.hop_dir !== \"res\") return false;\n    this.pktResolveRequest(pkt);\n    return true;\n  }\n  /** register client with client endpoint info */\n  async registerClient(info) {\n    const fn = \"registerClient:\";\n    if (!this.cli_gateway) throw Error(`${fn} no gateway`);\n    const pkt = this.newRegPacket();\n    pkt.data = { ...info };\n    const { msg } = pkt;\n    const requestReg = new Promise((resolve, reject) => {\n      const hash = GetPacketHashString2(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.urnet_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.cli_gateway.send(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    let regData = await requestReg;\n    const { ok, status, error } = regData;\n    if (error) {\n      LOG5(`${fn} error:`, error);\n      return regData;\n    }\n    if (ok) {\n      LOG5(\"** REGISTERED **\", status);\n      this.cli_reg = info;\n      return regData;\n    }\n    throw Error(`${fn} unexpected response`, regData);\n  }\n  /** create a registration packet */\n  newRegPacket() {\n    const pkt = this.newPacket(\"SRV:REG\");\n    pkt.setMeta(\"_reg\", { rsvp: true });\n    return pkt;\n  }\n  /** handle registration response packet directly rather than through\n   *  the netcall interface in pktReceive() */\n  handleRegResponse(pkt) {\n    const fn = \"handleRegResponse:\";\n    if (pkt.msg_type !== \"_reg\") return false;\n    if (pkt.hop_dir !== \"res\") return false;\n    if (pkt.src_addr !== this.urnet_addr) throw Error(`${fn} misaddressed packet???`);\n    this.pktResolveRequest(pkt);\n    return true;\n  }\n  /** declare client messages */\n  async clientDeclare() {\n    const msg_list = this.listNetMessages();\n    return await this.clientDeclareServices({ msg_list });\n  }\n  /** declare client attributes */\n  async clientDeclareServices(def) {\n    const fn = \"clientDeclareServices:\";\n    if (!this.cli_gateway) throw Error(`${fn} no gateway`);\n    const pkt = this.newDeclPacket();\n    pkt.data = { ...def };\n    const { msg } = pkt;\n    const decSvcs = new Promise((resolve, reject) => {\n      const hash = GetPacketHashString2(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.urnet_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.cli_gateway.send(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    let declared = await decSvcs;\n    const { error, status } = declared;\n    if (error) {\n      LOG5(`${fn} error:`, error);\n      return declared;\n    }\n    if (status) {\n      LOG5(\"** DECLARED **\", status);\n      return declared;\n    }\n    throw Error(`${fn} unexpected response`, declared);\n  }\n  /** create a definition packet */\n  newDeclPacket() {\n    const pkt = this.newPacket(\"SRV:DEF\");\n    pkt.setMeta(\"_decl\", { rsvp: true });\n    return pkt;\n  }\n  handleDeclResponse(pkt) {\n    const fn = \"handleDeclResponse:\";\n    if (pkt.msg_type !== \"_decl\") return false;\n    if (pkt.hop_dir !== \"res\") return false;\n    if (pkt.src_addr !== this.urnet_addr) throw Error(`${fn} misaddressed packet???`);\n    this.pktResolveRequest(pkt);\n    return true;\n  }\n  /** disables down the gateway */\n  disconnectAsClient() {\n    this.cli_gateway = void 0;\n  }\n  /** endpoint lookup tables - - - - - - - - - - - - - - - - - - - -  - - - **/\n  /** get list of messages allocated to a uaddr */\n  getMessagesForAddress(uaddr) {\n    const fn = \"getMessagesForAddress:\";\n    if (!this.isServer()) return [];\n    if (typeof uaddr !== \"string\") throw Error(`${fn} invalid uaddr`);\n    if (!this.srv_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    const msg_list = [];\n    this.srv_msgs.forEach((addr_set, msg) => {\n      if (addr_set.has(uaddr)) msg_list.push(msg);\n    });\n    return msg_list;\n  }\n  /** get list of UADDRs that a message is forwarded to */\n  getAddressesForMessage(msg) {\n    const fn = \"getAddressesForMessage:\";\n    if (!this.isServer()) return [];\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    const key = NormalizeMessage2(msg);\n    if (!this.srv_msgs.has(key)) this.srv_msgs.set(key, /* @__PURE__ */ new Set());\n    const addr_set = this.srv_msgs.get(key);\n    const addr_list = Array.from(addr_set);\n    return addr_list;\n  }\n  /** return list of local handlers for given message */\n  getHandlersForMessage(msg) {\n    const fn = \"getHandlersForMessage:\";\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    const key = NormalizeMessage2(msg);\n    if (!this.msg_handlers.has(key))\n      this.msg_handlers.set(key, /* @__PURE__ */ new Set());\n    const handler_set = this.msg_handlers.get(key);\n    if (!handler_set) throw Error(`${fn} unexpected empty set '${key}'`);\n    const handler_list = Array.from(handler_set);\n    return handler_list;\n  }\n  /** informational routing information - - - - - - - - - - - - - - - - - - **/\n  /** return handler list for this endpoint */\n  listMessages() {\n    const list = [];\n    this.msg_handlers.forEach((handler_set, key) => {\n      list.push(key);\n    });\n    return list;\n  }\n  /** return only net messages */\n  listNetMessages() {\n    const list = [];\n    this.msg_handlers.forEach((handler_set, key) => {\n      if (IsNetMessage2(key)) list.push(key);\n    });\n    return list;\n  }\n  /** return list of active transactions for this endpoint */\n  listTransactions() {\n    const fn = \"listTransactions:\";\n    const list = [];\n    this.transactions.forEach((transaction, hash) => {\n      const { msg, uaddr } = transaction;\n      list.push({ hash, msg, uaddr });\n    });\n    return list;\n  }\n  /** server endpoints manage list of messages in clients  - - - - -  - - - **/\n  /** register a message handler for a given message to passed uaddr */\n  registerRemoteMessages(uaddr, msgList) {\n    const fn = \"registerRemoteMessages:\";\n    if (typeof uaddr !== \"string\") throw Error(`${fn} invalid uaddr`);\n    if (!this.srv_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    this._setRemoteMessages(uaddr, msgList);\n  }\n  /** secret utility function for registerRemoteMessages */\n  _setRemoteMessages(uaddr, msgList) {\n    const fn = \"_setRemoteMessages:\";\n    msgList.forEach((msg) => {\n      if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n      if (msg !== msg.toUpperCase()) throw Error(`${fn} msg must be uppercase`);\n      const key = NormalizeMessage2(msg);\n      if (!this.srv_msgs.has(key)) this.srv_msgs.set(key, /* @__PURE__ */ new Set());\n      const msg_set = this.srv_msgs.get(key);\n      msg_set.add(uaddr);\n    });\n  }\n  /** unregister message handlers for a given message to passed uaddr */\n  _delRemoteMessages(uaddr) {\n    const fn = \"_delRemoteMessages:\";\n    if (typeof uaddr !== \"string\") throw Error(`${fn} invalid uaddr`);\n    if (!this.srv_socks.has(uaddr)) throw Error(`${fn} unknown uaddr ${uaddr}`);\n    const removed = [];\n    this.srv_msgs.forEach((msg_set, key) => {\n      if (msg_set.has(uaddr)) removed.push(key);\n      msg_set.delete(uaddr);\n    });\n    return removed;\n  }\n  /** packet utility - - - - - - - - - - - - - - - - - - - - - - - - - - - -**/\n  assignPacketId(pkt) {\n    if (pkt.src_addr === void 0) pkt.src_addr = this.urnet_addr;\n    const count = ++this.pkt_counter;\n    pkt.id = `pkt[${pkt.src_addr}:${count}]`;\n    return pkt.id;\n  }\n  /** convert JSON to packet and return */\n  packetFromJSON(json) {\n    const pkt = new NetPacket2();\n    pkt.setFromJSON(json);\n    return pkt;\n  }\n  /** create a new packet with proper address */\n  newPacket(msg, data) {\n    const fn = \"newPacket:\";\n    const pkt = new NetPacket2(msg, data);\n    pkt.setSrcAddr(this.urnet_addr || UADDR_NONE2);\n    if (this.cli_auth) pkt.setAuth(this.cli_auth);\n    pkt.id = this.assignPacketId(pkt);\n    return pkt;\n  }\n  /** clone a packet with new id */\n  clonePacket(pkt) {\n    const clone = this.newPacket(pkt.msg, pkt.data);\n    clone.setFromJSON(pkt.serialize());\n    clone.src_addr = this.urnet_addr;\n    clone.id = this.assignPacketId(clone);\n    return clone;\n  }\n  /** message declaration and invocation - - - - - - - - - - - - - - - - - -**/\n  /** declare a message handler for a given message */\n  registerMessage(msg, handler) {\n    const fn = \"registerMessage:\";\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    if (msg !== msg.toUpperCase()) throw Error(`${fn} msg must be uppercase`);\n    if (typeof handler !== \"function\") throw Error(`${fn} invalid handler`);\n    const key = NormalizeMessage2(msg);\n    if (!this.msg_handlers.has(key))\n      this.msg_handlers.set(key, /* @__PURE__ */ new Set());\n    const handler_set = this.msg_handlers.get(key);\n    handler_set.add(handler);\n  }\n  /** remove a previously declared message handler for a given message */\n  removeHandler(msg, handler) {\n    const fn = \"removeHandler:\";\n    if (typeof msg !== \"string\") throw Error(`${fn} invalid msg`);\n    if (typeof handler !== \"function\") throw Error(`${fn} invalid handler`);\n    const key = NormalizeMessage2(msg);\n    const handler_set = this.msg_handlers.get(key);\n    if (!handler_set) throw Error(`${fn} unexpected empty set '${key}'`);\n    handler_set.delete(handler);\n  }\n  /** call local message registered on this endPoint only */\n  async call(msg, data) {\n    const fn = \"call:\";\n    if (!IsLocalMessage2(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getHandlersForMessage(msg);\n    const promises = [];\n    handlers.forEach((handler) => {\n      promises.push(\n        new Promise((resolve, reject) => {\n          try {\n            resolve(handler({ ...data }));\n          } catch (err) {\n            reject(err);\n          }\n        })\n      );\n    });\n    if (promises.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    const resData = await Promise.all(promises);\n    return resData;\n  }\n  /** send local message registered on this endPoint only, returning no data */\n  async send(msg, data) {\n    const fn = \"send:\";\n    if (!IsLocalMessage2(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getHandlersForMessage(msg);\n    if (handlers.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    handlers.forEach((handler) => {\n      handler({ ...data });\n    });\n    return Promise.resolve(true);\n  }\n  /** signal local message registered on this endPoint only, returning no data.\n   */\n  async signal(msg, data) {\n    const fn = \"signal:\";\n    if (!IsLocalMessage2(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getHandlersForMessage(msg);\n    if (handlers.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    handlers.forEach((handler) => {\n      handler({ ...data });\n    });\n    return Promise.resolve(true);\n  }\n  /** ping local message, return with number of handlers */\n  async ping(msg) {\n    const fn = \"ping:\";\n    if (!IsLocalMessage2(msg)) throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getHandlersForMessage(msg);\n    return Promise.resolve(handlers.length);\n  }\n  /** call net message, resolves when packet returns from server with data */\n  async netCall(msg, data) {\n    const fn = \"netCall:\";\n    if (!IsNetMessage2(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg, data);\n    pkt.setMeta(\"call\", {\n      dir: \"req\",\n      rsvp: true\n    });\n    const p = new Promise((resolve, reject) => {\n      const hash = GetPacketHashString2(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.urnet_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.pktSendRequest(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    let resData = await p;\n    return resData;\n  }\n  /** send net message, returning promise that will resolve when the server has\n   *  received and processed/forwarded the message */\n  async netSend(msg, data) {\n    const fn = \"netSend:\";\n    if (!IsNetMessage2(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const p = new Promise((resolve, reject) => {\n      const pkt = this.newPacket(msg, data);\n      pkt.setMeta(\"send\", {\n        dir: \"req\",\n        rsvp: true\n      });\n      const hash = GetPacketHashString2(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.urnet_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.pktSendRequest(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    let resData = await p;\n    return resData;\n  }\n  /** signal net message, returning void (not promise)\n   *  used for the idea of 'raising signals' as opposed to 'sending data'. It\n   *  resolves immediately when the signal is sent, and does not check with the\n   *  server  */\n  netSignal(msg, data) {\n    const fn = \"netSignal:\";\n    if (!IsNetMessage2(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg, data);\n    pkt.setMeta(\"signal\", {\n      dir: \"req\",\n      rsvp: false\n    });\n    this.pktSendRequest(pkt);\n  }\n  /** returns with a list of uaddr from the server which is the uaddr of the\n   *  all clients that have registered for the message */\n  async netPing(msg) {\n    const fn = \"netPing:\";\n    if (!IsNetMessage2(msg)) throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg);\n    pkt.setMeta(\"ping\", {\n      dir: \"req\",\n      rsvp: true\n    });\n    const p = new Promise((resolve, reject) => {\n      const hash = GetPacketHashString2(pkt);\n      if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.urnet_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.pktSendRequest(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    let resData = await p;\n    return resData;\n  }\n  /** packet interface  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** Receive a single packet from the wire, and determine\n   *  what to do with it. The packet has several possible\n   *  processing options!\n   *  - packet is response to an outgoing transaction\n   *  - packet is a message that we handle\n   *  - packet is a message that we forward\n   *  - packet is unknown message so we return it with error\n   *  If the packet has the rsvp flag set, we need to return\n   *  it to the source address in the packet with any data\n   */\n  async pktReceive(pkt) {\n    try {\n      const fn = \"pktReceive:\";\n      if (pkt.isResponse()) {\n        if (pkt.src_addr === this.urnet_addr) this.pktResolveRequest(pkt);\n        else this.pktSendResponse(pkt);\n        return;\n      }\n      if (!pkt.isRequest()) {\n        LOG5(this.urnet_addr, fn, `invalid packet`, pkt);\n        return;\n      }\n      if (pkt.msg_type === \"ping\") {\n        const addrs = this.getAddressesForMessage(pkt.msg);\n        const handlers = this.getHandlersForMessage(pkt.msg);\n        if (handlers.length > 0) addrs.push(this.urnet_addr);\n        pkt.setData(addrs);\n        this.pktSendResponse(pkt);\n        return;\n      }\n      if (pkt.msg_type === \"signal\") {\n        if (DBG2) LOG5(_PKT(this, fn, \"-recv-sig-\", pkt), pkt.data);\n        LOG5(\"would handle signal\", pkt.msg);\n      }\n      const { msg } = pkt;\n      let retData;\n      if (this.msg_handlers.has(msg)) {\n        retData = await this.pktAwaitHandlers(pkt);\n      } else if (this.srv_msgs.has(msg)) {\n        retData = await this.pktAwaitRequest(pkt);\n      } else {\n        LOG5(this.urnet_addr, fn, `unknown message '${msg}'`, pkt);\n        retData = { error: `unknown message '${msg}'` };\n      }\n      if (!pkt.isRsvp()) return;\n      if (pkt.msg_type !== \"call\") pkt.data = true;\n      else {\n        retData = NormalizeData2(retData);\n        pkt.setData(retData);\n      }\n      this.pktSendResponse(pkt);\n    } catch (err) {\n      LOG5(err.message);\n      LOG5(err.stack.split(\"\\n\").slice(1).join(\"\\n\").trim());\n    }\n  }\n  /** Send a single packet on all available interfaces based on the\n   *  message. And endpoint can be a client (with gateway) or a server\n   *  (with clients). Use for initial outgoing packets only.\n   */\n  pktSendRequest(pkt) {\n    const fn = \"pktSendRequest:\";\n    if (pkt.src_addr === void 0) throw Error(`${fn}src_addr undefined`);\n    if (this.urnet_addr === void 0) throw Error(`${fn} urnet_addr undefined`);\n    if (pkt.hop_seq.length !== 0) throw Error(`${fn} pkt must have no hops yet`);\n    if (pkt.msg_type !== \"ping\" && pkt.data === void 0)\n      throw Error(`${fn} data undefined`);\n    if (DBG2) LOG5(_PKT(this, fn, \"-send-req-\", pkt), pkt.data);\n    const { gateway, clients } = this.pktGetSocketRouting(pkt);\n    pkt.addHop(this.urnet_addr);\n    if (gateway) {\n      if (this.cli_reg === void 0) throw Error(`${fn} endpoint not registered`);\n      gateway.send(pkt);\n    }\n    if (Array.isArray(clients)) {\n      clients.forEach((sock) => sock.send(pkt));\n    }\n  }\n  /** Given a packet and a socket, clone it and then return a\n   *  promise that sends it out on all network interfaces. This\n   *  is used by server endpoints as a utility to send a clone\n   *  packet on a particular socket to a particular address.\n   */\n  pktQueueRequest(pkt, sock) {\n    const fn = \"pktQueueRequest:\";\n    const clone = this.clonePacket(pkt);\n    clone.id = this.assignPacketId(clone);\n    const hash = GetPacketHashString2(clone);\n    if (this.transactions.has(hash)) throw Error(`${fn} duplicate hash ${hash}`);\n    const p = new Promise((resolve, reject) => {\n      const meta = { msg: pkt.msg, uaddr: pkt.src_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      sock.send(clone);\n    });\n    return p;\n  }\n  /** Resolve a transaction when a packet is returned to it through\n   *  pktReceive(pkt) which determines that it is a returning transaction\n   */\n  pktResolveRequest(pkt) {\n    const fn = \"pktResolveRequest:\";\n    if (pkt.hop_rsvp !== true) throw Error(`${fn} packet is not RSVP`);\n    if (pkt.hop_dir !== \"res\") throw Error(`${fn} packet is not a response`);\n    if (pkt.hop_seq.length < 2 && !pkt.isProtocol())\n      throw Error(`${fn} packet has no hops`);\n    const hash = GetPacketHashString2(pkt);\n    const resolver = this.transactions.get(hash);\n    if (!resolver) throw Error(`${fn} no resolver for hash ${hash}`);\n    const { resolve, reject } = resolver;\n    const { data } = pkt;\n    if (DBG2) LOG5(_PKT(this, fn, \"-recv-res-\", pkt), pkt.data);\n    if (pkt.err) reject(pkt.err);\n    else resolve(data);\n    this.transactions.delete(hash);\n  }\n  /** Return a packet to its source address. If this endpoint is a server,\n   *  then it might have the socket stored. Otherwise, if this endpoint is\n   *  also a client of another server, pass the back through the gateway.\n   *  This is used by server endpoints to return packets to clients.\n   */\n  pktSendResponse(pkt) {\n    const fn = \"pktSendResponse:\";\n    if (pkt.hop_rsvp !== true) throw Error(`${fn} packet is not RSVP`);\n    if (pkt.hop_seq.length < 1) throw Error(`${fn} packet has no hops`);\n    pkt.setDir(\"res\");\n    pkt.addHop(this.urnet_addr);\n    if (DBG2) LOG5(_PKT(this, fn, \"-send-res-\", pkt), pkt.data);\n    const { gateway, src_addr } = this.pktGetSocketRouting(pkt);\n    if (this.isServer()) {\n      const socket = this.getClient(src_addr);\n      if (socket) socket.send(pkt);\n      return;\n    }\n    if (gateway) {\n      gateway.send(pkt);\n      return;\n    }\n    if (DBG2) LOG5(`${fn} unroutable packet`, pkt);\n  }\n  /** Start a transaction, which returns promises to await. This method\n   *  is a queue that uses Promises to wait for the return, which is\n   *  triggered by a returning packet in pktReceive(pkt).\n   */\n  async pktAwaitRequest(pkt) {\n    const fn = \"pktAwaitRequest:\";\n    if (pkt.hop_dir !== \"req\") throw Error(`${fn} packet is not a request`);\n    const { gateway, clients } = this.pktGetSocketRouting(pkt);\n    const promises = [];\n    if (gateway) {\n      if (DBG2) LOG5(_PKT(this, fn, \"-wait-req-\", pkt), pkt.data);\n      promises.push(this.pktQueueRequest(pkt, gateway));\n    }\n    if (Array.isArray(clients)) {\n      if (DBG2) LOG5(_PKT(this, fn, \"-wait-req-\", pkt), pkt.data);\n      clients.forEach((sock) => {\n        promises.push(this.pktQueueRequest(pkt, sock));\n      });\n    }\n    let data = await Promise.all(promises);\n    if (Array.isArray(data) && data.length === 1) data = data[0];\n    if (DBG2) LOG5(_PKT(this, fn, \"-retn-req-\", pkt), pkt.data);\n    return data;\n  }\n  /** Start a handler call, which might have multiple implementors.\n   *  Returns data from all handlers as an array or a single item\n   */\n  async pktAwaitHandlers(pkt) {\n    const fn = \"pktAwaitHandlers:\";\n    const { msg } = pkt;\n    const handlers = this.getHandlersForMessage(msg);\n    if (handlers.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    const promises = [];\n    if (DBG2) LOG5(_PKT(this, fn, \"-wait-hnd-\", pkt), pkt.data);\n    handlers.forEach((handler) => {\n      promises.push(\n        new Promise((resolve, reject) => {\n          try {\n            resolve(handler({ ...pkt.data }));\n          } catch (err) {\n            reject(err);\n          }\n        })\n      );\n    });\n    let data = await Promise.all(promises);\n    if (Array.isArray(data) && data.length === 1) data = data[0];\n    if (DBG2) LOG5(_PKT(this, fn, \"-retn-hnd-\", pkt), pkt.data);\n    return data;\n  }\n  /** return array of sockets to use for sending packet,\n   *  based on pkt.msg and pkt.src_addr\n   */\n  pktGetSocketRouting(pkt) {\n    const fn = \"pktGetSocketRouting:\";\n    const { msg, src_addr } = pkt;\n    if (!IsNetMessage2(msg)) throw Error(`${fn} '${msg}' is invalid message`);\n    const gateway = this.cli_gateway;\n    const self_addr = this.urnet_addr;\n    const msg_list = this.getAddressesForMessage(msg);\n    const clients = [];\n    msg_list.forEach((uaddr) => {\n      LOG5(\"uaddr\", uaddr);\n      if (uaddr === this.urnet_addr) return;\n      const socket = this.getClient(uaddr);\n      if (socket) clients.push(socket);\n    });\n    return {\n      msg,\n      src_addr,\n      self_addr,\n      gateway,\n      clients\n    };\n  }\n};\n\n// _ur_addons/net/class-urnet-socket.ts\nvar PR8 = typeof process !== \"undefined\" ? \"Socket\".padEnd(13) : \"Socket:\";\nvar NetSocket2 = class {\n  // name of the socket-ish object\n  constructor(connectObj, io) {\n    __publicField(this, \"connector\");\n    // the original connection object\n    __publicField(this, \"sendFunc\");\n    // the outgoing send function for this socket\n    __publicField(this, \"onDataFunc\");\n    // the incoming data function for this socket\n    //\n    __publicField(this, \"uaddr\");\n    // assigned uaddr for this socket-ish object\n    __publicField(this, \"auth\");\n    // whatever authentication is needed for this socket\n    __publicField(this, \"msglist\");\n    // messages queued for this socket\n    __publicField(this, \"age\");\n    // number of seconds since this socket was used\n    __publicField(this, \"label\");\n    this.connector = connectObj;\n    const { send, onData } = io;\n    this.sendFunc = send.bind(connectObj);\n    this.onDataFunc = onData.bind(connectObj);\n  }\n  send(pkt) {\n    this.sendFunc(pkt);\n  }\n  getConnector() {\n    return this.connector;\n  }\n};\n\n// _ur_addons/comment/ac-comment.ts\nvar ac_comment_exports = {};\n__export(ac_comment_exports, {\n  AddComment: () => AddComment2,\n  CloseCommentCollection: () => CloseCommentCollection,\n  DeriveAllThreadedViewObjects: () => DeriveAllThreadedViewObjects,\n  DeriveThreadedViewObjects: () => DeriveThreadedViewObjects,\n  GetCOMMENTS: () => GetCOMMENTS2,\n  GetCOMMENTVOBJS: () => GetCOMMENTVOBJS,\n  GetComment: () => GetComment2,\n  GetCommentBeingEdited: () => GetCommentBeingEdited,\n  GetCommentCollection: () => GetCommentCollection,\n  GetCommentCollections: () => GetCommentCollections,\n  GetCommentStats: () => GetCommentStats,\n  GetCommentType: () => GetCommentType2,\n  GetCommentTypes: () => GetCommentTypes2,\n  GetCommentUIState: () => GetCommentUIState,\n  GetCommentVObj: () => GetCommentVObj,\n  GetCrefs: () => GetCrefs2,\n  GetDateString: () => GetDateString,\n  GetDefaultCommentType: () => GetDefaultCommentType2,\n  GetOpenComments: () => GetOpenComments,\n  GetReadby: () => GetReadby2,\n  GetThreadedViewObjects: () => GetThreadedViewObjects,\n  GetThreadedViewObjectsCount: () => GetThreadedViewObjectsCount,\n  GetUnreadComments: () => GetUnreadComments,\n  GetUnreadRepliesToMe: () => GetUnreadRepliesToMe,\n  GetUserName: () => GetUserName2,\n  HandleRemovedComments: () => HandleRemovedComments2,\n  HandleUpdatedComments: () => HandleUpdatedComments2,\n  Init: () => Init2,\n  LoadDB: () => LoadDB2,\n  LoadTemplate: () => LoadTemplate2,\n  MarkRead: () => MarkRead,\n  RemoveAllCommentsForCref: () => RemoveAllCommentsForCref2,\n  RemoveComment: () => RemoveComment2,\n  UpdateComment: () => UpdateComment2,\n  UpdateCommentUIState: () => UpdateCommentUIState\n});\n\n// _ur_addons/comment/dc-comment.ts\nvar DBG3 = false;\nvar PR9 = \"dc-comments\";\nvar USERS = /* @__PURE__ */ new Map();\nvar COMMENTTYPES = /* @__PURE__ */ new Map();\nvar COMMENTS = /* @__PURE__ */ new Map();\nvar READBY = /* @__PURE__ */ new Map();\nvar ROOTS = /* @__PURE__ */ new Map();\nvar REPLY_ROOTS = /* @__PURE__ */ new Map();\nvar NEXT = /* @__PURE__ */ new Map();\nvar DEFAULT_CommentTypes = [\n  // Add default comment type if none are defined\n  {\n    slug: \"cmt\",\n    label: \"Comment\",\n    // comment type label\n    prompts: [\n      {\n        format: \"text\",\n        prompt: \"Comment\",\n        // prompt label\n        help: \"Use this for any general comment.\",\n        feedback: \"\"\n      }\n    ]\n  }\n  // Temporarily moved into template 2024-07-30\n  // Move eventually to new templating system\n  //\n  // {\n  //   slug: 'demo',\n  //   label: 'Demo',\n  //   prompts: [\n  //     {\n  //       format: 'text',\n  //       prompt: 'Comment', // prompt label\n  //       help: 'Use this for any general comment.',\n  //       feedback: 'Just enter text'\n  //     },\n  //     {\n  //       format: 'dropdown',\n  //       prompt: 'How often did you use \"Dropdown\"', // prompt label\n  //       options: ['🥲 No', '🤔 A little', '😀 A lot'],\n  //       help: 'Select one.',\n  //       feedback: 'Single selection via dropdown menu'\n  //     },\n  //     {\n  //       format: 'checkbox',\n  //       prompt: 'What types of fruit did you \"Checkbox\"?', // prompt label\n  //       options: ['Apple Pie', 'Orange, Lime', 'Banana'],\n  //       help: 'Select as many as you want.',\n  //       feedback: 'Supports multiple selections'\n  //     },\n  //     {\n  //       format: 'radio',\n  //       prompt: 'What do you think \"Radio\"?', // prompt label\n  //       options: [\n  //         'It makes sense',\n  //         'I disagree',\n  //         \"I don't know\",\n  //         'Handle, comma, please'\n  //       ],\n  //       help: 'Select only one.',\n  //       feedback: 'Mutually exclusive single selections'\n  //     },\n  //     {\n  //       format: 'likert',\n  //       prompt: 'How did you like it \"likert\"?', // prompt label\n  //       options: ['💙', '💚', '💛', '🧡', '🩷'],\n  //       help: 'Select one of a series listed horizontally',\n  //       feedback: 'Select with a single click.  Supports emojis.'\n  //     },\n  //     {\n  //       format: 'discrete-slider',\n  //       prompt: 'Star Rating \"discrete-slider\"?', // prompt label\n  //       options: ['★', '★', '★', '★', '★'],\n  //       help: 'Select one of a series stacked horizontally',\n  //       feedback: 'Select with a single click.  Supports emojis.'\n  //     },\n  //     {\n  //       format: 'text',\n  //       prompt: 'Comment 2', // prompt label\n  //       help: 'Use this for any general comment.',\n  //       feedback: 'Just enter text'\n  //     },\n  //     {\n  //       format: 'text',\n  //       prompt: 'Comment 3', // prompt label\n  //       help: 'Use this for any general comment.',\n  //       feedback: 'Just enter text'\n  //     }\n  //   ]\n  // },\n  // {\n  //   slug: 'cmt',\n  //   label: 'Comment', // comment type label\n  //   prompts: [\n  //     {\n  //       format: 'text',\n  //       prompt: 'Comment', // prompt label\n  //       help: 'Use this for any general comment.',\n  //       feedback: ''\n  //     }\n  //   ]\n  // },\n  // {\n  //   slug: 'tellmemore',\n  //   label: 'Tell me more', // comment type label\n  //   prompts: [\n  //     {\n  //       format: 'text',\n  //       prompt: 'Please tell me more', // prompt label\n  //       help: 'Can you tell me more about ... ',\n  //       feedback: ''\n  //     }\n  //   ]\n  // },\n  // {\n  //   slug: 'source',\n  //   label: 'Source', // comment type label\n  //   prompts: [\n  //     {\n  //       format: 'text',\n  //       prompt: 'Is this well sourced?', // prompt label\n  //       help: 'Yes/No',\n  //       feedback: ''\n  //     },\n  //     {\n  //       format: 'text',\n  //       prompt: 'Changes', // prompt label\n  //       help: 'What about the sourcing could be improved?',\n  //       feedback: ''\n  //     }\n  //   ]\n  // }\n];\nfunction m_LoadUsers(dbUsers) {\n  dbUsers.forEach((u) => USERS.set(u.id, u.name));\n}\nfunction m_LoadCommentTypes(commentTypes) {\n  commentTypes.forEach((t) => COMMENTTYPES.set(t.slug, t));\n}\nfunction m_LoadComments(comments) {\n  comments.forEach((c) => COMMENTS.set(c.comment_id, c));\n}\nfunction m_LoadReadBy(readby) {\n  readby.forEach((r) => READBY.set(r.comment_id, r.commenter_ids));\n}\nfunction Init() {\n  if (DBG3) console.log(PR9, \"Init\");\n}\nfunction LoadTemplate(commentTypes) {\n  const types = commentTypes || DEFAULT_CommentTypes;\n  m_LoadCommentTypes(types);\n}\nfunction LoadDB(data) {\n  if (DBG3) console.log(PR9, \"LoadDB\");\n  if (data.commenttypes) m_LoadCommentTypes(data.commenttypes);\n  else m_LoadCommentTypes(DEFAULT_CommentTypes);\n  if (data.users) m_LoadUsers(data.users);\n  if (data.comments) m_LoadComments(data.comments);\n  if (data.readby) m_LoadReadBy(data.readby);\n  if (DBG3) console.log(\"USERS\", USERS);\n  if (DBG3) console.log(\"COMMENTTYPES\", COMMENTTYPES);\n  if (DBG3) console.log(\"COMMENTS\", COMMENTS);\n  if (DBG3) console.log(\"READBY\", READBY);\n  m_DeriveValues();\n}\nfunction GetUsers() {\n  return USERS;\n}\nfunction GetUser(uid) {\n  return USERS.get(uid);\n}\nfunction GetUserName(uid) {\n  const u = USERS.get(uid);\n  return u !== void 0 ? u : uid;\n}\nfunction GetCurrentUser() {\n  return \"Ben32\";\n}\nfunction GetCommentTypes() {\n  return COMMENTTYPES;\n}\nfunction GetCommentType(typeid) {\n  return COMMENTTYPES.get(typeid);\n}\nfunction GetDefaultCommentType() {\n  if (DEFAULT_CommentTypes.length < 1)\n    throw new Error(\"dc-comments: No comment types defined!\");\n  return GetCommentType(DEFAULT_CommentTypes[0].slug);\n}\nfunction GetCOMMENTS() {\n  return COMMENTS;\n}\nfunction GetComment(cid) {\n  return COMMENTS.get(cid);\n}\nfunction m_DeriveValues() {\n  ROOTS.clear();\n  REPLY_ROOTS.clear();\n  NEXT.clear();\n  COMMENTS.forEach((c) => {\n    if (c.comment_id_parent === \"\" && c.comment_id_previous === \"\")\n      ROOTS.set(c.collection_ref, c.comment_id);\n    if (c.comment_id_parent !== \"\" && c.comment_id_previous === \"\") {\n      REPLY_ROOTS.set(c.comment_id_parent, c.comment_id);\n    }\n    if (c.comment_id_previous !== \"\") {\n      NEXT.set(c.comment_id_previous, c.comment_id);\n    }\n  });\n  if (DBG3) console.log(\"ROOTS\", ROOTS);\n  if (DBG3) console.log(\"REPLY_ROOTS\", REPLY_ROOTS);\n  if (DBG3) console.log(\"NEXT\", NEXT);\n}\nfunction AddComment(data) {\n  if (data.cref === void 0)\n    throw new Error(\"Comments must have a collection ref!\");\n  const comment_id_parent = data.comment_id_parent || \"\";\n  const comment_id_previous = data.comment_id_previous || \"\";\n  const comment = {\n    collection_ref: data.cref,\n    comment_id: data.comment_id,\n    // thread\n    comment_id_parent,\n    comment_id_previous,\n    comment_type: \"cmt\",\n    // default type, no prompts\n    comment_createtime: (/* @__PURE__ */ new Date()).getTime(),\n    comment_modifytime: null,\n    comment_isMarkedDeleted: data.comment_isMarkedDeleted,\n    commenter_id: data.commenter_id,\n    commenter_text: []\n  };\n  COMMENTS.set(comment.comment_id, comment);\n  m_DeriveValues();\n  return comment;\n}\nfunction UpdateComment(cobj) {\n  m_UpdateComment(cobj);\n  m_DeriveValues();\n}\nfunction m_UpdateComment(cobj) {\n  cobj.comment_modifytime = (/* @__PURE__ */ new Date()).getTime();\n  console.log(\n    \"REVIEW: UpdateComment...modify time should use loki time???\",\n    cobj.comment_modifytime\n  );\n  COMMENTS.set(cobj.comment_id, cobj);\n}\nfunction HandleUpdatedComments(cobjs) {\n  cobjs.forEach((cobj) => m_UpdateComment(cobj));\n  m_DeriveValues();\n}\nfunction RemoveComment(parms) {\n  const { collection_ref, comment_id, uid, isAdmin } = parms;\n  const queuedActions = [];\n  let deleteTarget = false;\n  let deleteTargetAndNext = false;\n  let deleteRootAndChildren = false;\n  let markDeleted = false;\n  let relinkNext = false;\n  const cidToDelete = comment_id;\n  const cobjToDelete = COMMENTS.get(cidToDelete);\n  const cobjIsRoot = cobjToDelete.comment_id_parent === \"\";\n  if (isAdmin) {\n    if (cobjIsRoot) {\n      deleteRootAndChildren = true;\n      relinkNext = true;\n    } else {\n      deleteTargetAndNext = true;\n    }\n  } else {\n    if (cobjIsRoot) {\n      const hasChildReplies = REPLY_ROOTS.get(cidToDelete);\n      if (!hasChildReplies) {\n        deleteTarget = true;\n        const hasNext = NEXT.get(cidToDelete);\n        if (hasNext) relinkNext = true;\n      } else markDeleted = true;\n    } else {\n      const hasNext = NEXT.get(cidToDelete);\n      if (hasNext) markDeleted = true;\n      else deleteTarget = true;\n    }\n  }\n  if (deleteRootAndChildren) {\n    if (DBG3) console.log(`deleteRootAndChildren`);\n    const childThreadIds = [];\n    COMMENTS.forEach((cobj) => {\n      if (cobj.comment_id_parent === cidToDelete)\n        childThreadIds.push(cobj.comment_id);\n    });\n    childThreadIds.forEach((cid) => {\n      COMMENTS.delete(cid);\n      queuedActions.push({ commentID: cid });\n    });\n  }\n  if (deleteTargetAndNext) {\n    if (DBG3) console.log(`deleteTargetAndNext`);\n    const nextIds = m_GetNexts(cidToDelete);\n    nextIds.forEach((cid) => {\n      COMMENTS.delete(cid);\n      queuedActions.push({ commentID: cid });\n    });\n  }\n  if (relinkNext) {\n    if (DBG3) console.log(`relinkNext`);\n    if (!cobjIsRoot)\n      throw new Error(\n        `relinkNext a non-root comment are you sure?  Usually we don't relink! ${cidToDelete}`\n      );\n    const nextCid = NEXT.get(cidToDelete);\n    const nextCobj = COMMENTS.get(nextCid);\n    const prev = COMMENTS.get(cobjToDelete.comment_id_previous);\n    if (nextCobj) {\n      nextCobj.comment_id_previous = prev ? prev.comment_id : \"\";\n      COMMENTS.set(nextCobj.comment_id, nextCobj);\n      queuedActions.push({ comment: nextCobj });\n    }\n  }\n  if (deleteTarget || deleteTargetAndNext || deleteRootAndChildren) {\n    if (DBG3) console.log(\"deleteTarget or Root\", cidToDelete);\n    COMMENTS.delete(cidToDelete);\n    queuedActions.push({ commentID: cidToDelete });\n  } else if (markDeleted) {\n    if (DBG3) console.log(\"markDeleted\", cidToDelete);\n    cobjToDelete.comment_type = DEFAULT_CommentTypes[0].slug;\n    cobjToDelete.comment_isMarkedDeleted = true;\n    COMMENTS.set(cobjToDelete.comment_id, cobjToDelete);\n    queuedActions.push({ comment: cobjToDelete });\n  }\n  let rootId;\n  if (cobjIsRoot) rootId = comment_id;\n  else rootId = cobjToDelete.comment_id_parent;\n  if (m_AllAreMarkedDeleted(rootId)) {\n    if (DBG3) console.log(\"delete all!\");\n    const rootCobj = COMMENTS.get(rootId);\n    if (rootCobj) {\n      const nextCid = NEXT.get(rootId);\n      const nextCobj = COMMENTS.get(nextCid);\n      const prev = COMMENTS.get(rootCobj.comment_id_previous);\n      if (nextCobj) {\n        nextCobj.comment_id_previous = prev ? prev.comment_id : \"\";\n        COMMENTS.set(nextCobj.comment_id, nextCobj);\n        queuedActions.push({ comment: nextCobj });\n      }\n    }\n    const replyIds = m_GetReplies(rootId);\n    replyIds.forEach((cid) => {\n      if (COMMENTS.has(cid)) {\n        COMMENTS.delete(cid);\n        queuedActions.push({ commentID: cid });\n      }\n    });\n    if (COMMENTS.has(rootId)) {\n      COMMENTS.delete(rootId);\n      queuedActions.push({ commentID: rootId });\n    }\n  }\n  if (!cobjIsRoot) {\n    const rootId2 = cobjToDelete.comment_id_parent;\n    const replyIds = m_GetReplies(rootId2).reverse();\n    for (let i = 0; i < replyIds.length; i++) {\n      const cid = replyIds[i];\n      const cobj = COMMENTS.get(cid);\n      if (cobj && cobj.comment_isMarkedDeleted) {\n        COMMENTS.delete(cid);\n        queuedActions.push({ commentID: cid });\n      } else if (cobj && !cobj.comment_isMarkedDeleted) {\n        break;\n      }\n    }\n  }\n  m_DeriveValues();\n  return queuedActions;\n}\nfunction RemoveAllCommentsForCref(parms) {\n  const { collection_ref } = parms;\n  const queuedActions = [];\n  const cids = COMMENTS.forEach((cobj) => {\n    if (cobj.collection_ref === collection_ref) {\n      COMMENTS.delete(cobj.comment_id);\n      queuedActions.push({ commentID: cobj.comment_id });\n    }\n  });\n  m_DeriveValues();\n  return queuedActions;\n}\nfunction m_AllAreMarkedDeleted(rootCommentId) {\n  const allCommentIdsInThread = [rootCommentId, ...m_GetReplies(rootCommentId)];\n  const allCommentsInThread = allCommentIdsInThread.map((cid) => COMMENTS.get(cid));\n  let allAreMarkedDeleted = true;\n  allCommentsInThread.forEach((cobj) => {\n    if (!cobj) return;\n    if (!cobj.comment_isMarkedDeleted) allAreMarkedDeleted = false;\n  });\n  return allAreMarkedDeleted;\n}\nfunction HandleRemovedComments(comment_ids) {\n  comment_ids.forEach((comment_id) => {\n    if (DBG3) console.log(\"...removing\", comment_id);\n    COMMENTS.delete(comment_id);\n  });\n  m_DeriveValues();\n}\nfunction MarkCommentRead(cid, uid) {\n  const readby = READBY.get(cid) || [];\n  if (!readby.includes(uid)) readby.push(uid);\n  READBY.set(cid, readby);\n}\nfunction MarkCommentUnread(cid, uid) {\n  const readby = READBY.get(cid) || [];\n  const updatedReadby = readby.filter((readByUid) => readByUid !== uid);\n  READBY.set(cid, updatedReadby);\n}\nfunction IsMarkedRead(cid, uid) {\n  const readby = READBY.get(cid) || [];\n  return readby.includes(uid);\n}\nfunction IsMarkedDeleted(cid) {\n  return COMMENTS.get(cid).comment_isMarkedDeleted;\n}\nfunction m_GetNexts(cid) {\n  const results = [];\n  const nextId = NEXT.get(cid);\n  if (nextId) results.push(nextId, ...m_GetNexts(nextId));\n  return results;\n}\nfunction m_GetReplies(rootCid) {\n  const results = [];\n  const replyRootId = REPLY_ROOTS.get(rootCid);\n  if (replyRootId) results.push(replyRootId, ...m_GetNexts(replyRootId));\n  return results;\n}\nfunction m_GetRepliesAndNext(cid) {\n  const results = [];\n  const reply_root_id = REPLY_ROOTS.get(cid);\n  if (reply_root_id) {\n    results.push(reply_root_id, ...m_GetRepliesAndNext(reply_root_id));\n  }\n  const nextId = NEXT.get(cid);\n  if (nextId) {\n    results.push(nextId, ...m_GetRepliesAndNext(nextId));\n  }\n  return results;\n}\nfunction GetThreadedCommentIds(cref) {\n  const all_comments_ids = [];\n  const rootId = ROOTS.get(cref);\n  if (rootId === void 0) return [];\n  all_comments_ids.push(rootId, ...m_GetRepliesAndNext(rootId));\n  return all_comments_ids;\n}\nif (DBG3) console.log(\"GetThreadedView\", GetThreadedCommentIds(\"1\"));\nif (DBG3) console.log(\"GetThreadedView\", GetThreadedCommentIds(\"2\"));\nfunction GetThreadedCommentData(cref) {\n  const threaded_comments_ids = GetThreadedCommentIds(cref);\n  return threaded_comments_ids.map((cid) => COMMENTS.get(cid));\n}\nfunction GetReadby(cid) {\n  return READBY.get(cid);\n}\nfunction GetCrefs() {\n  return [...ROOTS.keys()];\n}\nvar dc_comment_default = {\n  Init,\n  LoadTemplate,\n  // DB\n  LoadDB,\n  // USERS\n  GetUsers,\n  GetUser,\n  GetUserName,\n  GetCurrentUser,\n  // COMMENT TYPES\n  GetCommentTypes,\n  GetCommentType,\n  GetDefaultCommentType,\n  // COMMENTS\n  GetCOMMENTS,\n  GetComment,\n  AddComment,\n  UpdateComment,\n  HandleUpdatedComments,\n  RemoveComment,\n  RemoveAllCommentsForCref,\n  HandleRemovedComments,\n  MarkCommentRead,\n  MarkCommentUnread,\n  IsMarkedRead,\n  IsMarkedDeleted,\n  GetThreadedCommentIds,\n  GetThreadedCommentData,\n  // GetThreadedCommentDataForRoot,\n  // READBY\n  GetReadby,\n  // ROOTS\n  GetCrefs\n};\n\n// _ur_addons/comment/ac-comment.ts\nvar DBG4 = true;\nvar PR10 = \"ac-comments\";\nvar COMMENTCOLLECTION = /* @__PURE__ */ new Map();\nvar COMMENTUISTATE = /* @__PURE__ */ new Map();\nvar OPENCOMMENTS = /* @__PURE__ */ new Map();\nvar COMMENTS_BEING_EDITED = /* @__PURE__ */ new Map();\nvar COMMENTVOBJS = /* @__PURE__ */ new Map();\nfunction Init2() {\n  if (DBG4) console.log(\"ac-comments Init\");\n  dc_comment_default.Init();\n}\nfunction LoadTemplate2(commentTypes) {\n  dc_comment_default.LoadTemplate(commentTypes);\n}\nfunction LoadDB2(data) {\n  if (DBG4) console.log(PR10, \"LoadDB\", data);\n  dc_comment_default.LoadDB(data);\n  if (DBG4) console.log(\"COMMENTCOLLECTION\", COMMENTCOLLECTION);\n  if (DBG4) console.log(\"COMMENTUISTATE\", COMMENTUISTATE);\n  if (DBG4) console.log(\"OPENCOMMENTS\", OPENCOMMENTS);\n  if (DBG4) console.log(\"COMMENTVOBJS\", COMMENTVOBJS);\n}\nfunction GetDateString(ms) {\n  return new Date(ms).toLocaleString();\n}\nfunction GetCommentCollections() {\n  return COMMENTCOLLECTION;\n}\nfunction GetCommentCollection(cref) {\n  const collection = COMMENTCOLLECTION.get(cref);\n  return collection;\n}\nfunction UpdateCommentUIState(uiref, openState) {\n  if (!uiref) throw new Error('UpdateCommentUIState \"uiref\" must be defined!');\n  COMMENTUISTATE.set(uiref, { cref: openState.cref, isOpen: openState.isOpen });\n  OPENCOMMENTS.set(openState.cref, uiref);\n}\nfunction CloseCommentCollection(uiref, cref, uid) {\n  COMMENTUISTATE.set(uiref, { cref, isOpen: false });\n  OPENCOMMENTS.set(cref, void 0);\n  MarkRead(cref, uid);\n  DeriveThreadedViewObjects(cref, uid);\n}\nfunction MarkRead(cref, uid) {\n  const commentVObjs = COMMENTVOBJS.get(cref);\n  commentVObjs.forEach((cvobj) => dc_comment_default.MarkCommentRead(cvobj.comment_id, uid));\n}\nfunction GetCommentStats(uid) {\n  let countRepliesToMe = 0;\n  let countUnread = 0;\n  DeriveAllThreadedViewObjects(uid);\n  const crefs = dc_comment_default.GetCrefs();\n  let rootCidsWithRepliesToMe = [];\n  crefs.forEach((cref) => {\n    const cvobjs = COMMENTVOBJS.get(cref);\n    cvobjs.find((cvobj) => {\n      const comment = dc_comment_default.GetComment(cvobj.comment_id);\n      if (comment.commenter_id === uid && comment.comment_id_parent !== \"\")\n        rootCidsWithRepliesToMe.push(comment.comment_id_parent);\n    });\n  });\n  COMMENTVOBJS.forEach((cvobjs) => {\n    cvobjs.forEach((cvobj) => {\n      if (!cvobj.isMarkedRead) {\n        countUnread++;\n        const comment = dc_comment_default.GetComment(cvobj.comment_id);\n        if (rootCidsWithRepliesToMe.includes(comment.comment_id_parent)) {\n          cvobj.isReplyToMe = true;\n          countRepliesToMe++;\n        }\n      }\n    });\n  });\n  return { countRepliesToMe, countUnread };\n}\nfunction GetCommentUIState(uiref) {\n  return COMMENTUISTATE.get(uiref);\n}\nfunction GetOpenComments(cref) {\n  return OPENCOMMENTS.get(cref);\n}\nfunction m_RegisterCommentBeingEdited(cid) {\n  COMMENTS_BEING_EDITED.set(cid, cid);\n}\nfunction m_DeRegisterCommentBeingEdited(cid) {\n  COMMENTS_BEING_EDITED.delete(cid);\n}\nfunction GetCommentBeingEdited(cid) {\n  return COMMENTS_BEING_EDITED.get(cid);\n}\nfunction GetUnreadRepliesToMe() {\n  const comments = [];\n  COMMENTVOBJS.forEach((cvobjs) => {\n    cvobjs.forEach((cvobj) => {\n      if (cvobj.isReplyToMe) comments.push(dc_comment_default.GetComment(cvobj.comment_id));\n    });\n  });\n  return comments;\n}\nfunction GetUnreadComments() {\n  const comments = [];\n  COMMENTVOBJS.forEach((cvobjs) => {\n    cvobjs.forEach((cvobj) => {\n      if (!cvobj.isMarkedRead) comments.push(dc_comment_default.GetComment(cvobj.comment_id));\n    });\n  });\n  return comments;\n}\nfunction DeriveAllThreadedViewObjects(uid) {\n  const crefs = dc_comment_default.GetCrefs();\n  crefs.forEach((cref) => DeriveThreadedViewObjects(cref, uid));\n}\nfunction DeriveThreadedViewObjects(cref, uid) {\n  if (cref === void 0)\n    throw new Error(`m_DeriveThreadedViewObjects cref: \"${cref}\" must be defined!`);\n  const commentVObjs = [];\n  const threadIds = dc_comment_default.GetThreadedCommentIds(cref);\n  threadIds.forEach((cid) => {\n    const comment = dc_comment_default.GetComment(cid);\n    if (comment === void 0)\n      console.error(\"GetThreadedViewObjects for cid not found\", cid, \"in\", threadIds);\n    const level = comment.comment_id_parent === \"\" ? 0 : 1;\n    commentVObjs.push({\n      comment_id: cid,\n      createtime_string: GetDateString(comment.comment_createtime),\n      modifytime_string: comment.comment_modifytime ? GetDateString(comment.comment_modifytime) : \"\",\n      level,\n      isSelected: false,\n      isBeingEdited: false,\n      isEditable: false,\n      isMarkedRead: dc_comment_default.IsMarkedRead(cid, uid),\n      allowReply: void 0\n      // will be defined next\n    });\n  });\n  const reversedCommentVObjs = commentVObjs.reverse();\n  const commentReplyVObjs = [];\n  let prevLevel = -1;\n  reversedCommentVObjs.forEach((cvobj) => {\n    if (cvobj.level === 0 && cvobj.level >= prevLevel || // is top level without a reply thread\n    cvobj.level > prevLevel)\n      cvobj.allowReply = true;\n    commentReplyVObjs.push(cvobj);\n    prevLevel = cvobj.level;\n  });\n  COMMENTVOBJS.set(cref, commentReplyVObjs.reverse());\n  const ccol = COMMENTCOLLECTION.get(cref) || {\n    collection_ref: cref\n  };\n  const hasReadComments = commentReplyVObjs.length > 0;\n  let hasUnreadComments = false;\n  commentReplyVObjs.forEach((c) => {\n    if (!c.isMarkedRead) hasUnreadComments = true;\n  });\n  ccol.hasUnreadComments = hasUnreadComments;\n  ccol.hasReadComments = hasReadComments;\n  COMMENTCOLLECTION.set(cref, ccol);\n  return commentReplyVObjs;\n}\nfunction GetThreadedViewObjects(cref, uid) {\n  const commentVObjs = COMMENTVOBJS.get(cref);\n  return commentVObjs === void 0 || commentVObjs.length === 0 ? DeriveThreadedViewObjects(cref, uid) : commentVObjs;\n}\nfunction GetThreadedViewObjectsCount(cref, uid) {\n  return GetThreadedViewObjects(cref, uid).length;\n}\nfunction GetCOMMENTVOBJS() {\n  return COMMENTVOBJS;\n}\nfunction GetCommentVObj(cref, cid) {\n  const thread = COMMENTVOBJS.get(cref);\n  const cvobj = thread.find((c) => c.comment_id === cid);\n  return cvobj;\n}\nfunction AddComment2(data) {\n  if (data.cref === void 0)\n    throw new Error(\"Comments must have a collection ref!\");\n  const comment = dc_comment_default.AddComment(data);\n  DeriveThreadedViewObjects(data.cref, data.commenter_id);\n  let commentVObjs = GetThreadedViewObjects(data.cref, data.commenter_id);\n  const cvobj = GetCommentVObj(comment.collection_ref, comment.comment_id);\n  if (cvobj === void 0)\n    console.error(\n      \"ac-comment:Could not find CommentVObj\",\n      comment.collection_ref,\n      comment.comment_id,\n      COMMENTVOBJS\n    );\n  cvobj.isBeingEdited = true;\n  m_RegisterCommentBeingEdited(comment.comment_id);\n  commentVObjs = commentVObjs.map(\n    (c) => c.comment_id === cvobj.comment_id ? cvobj : c\n  );\n  COMMENTVOBJS.set(data.cref, commentVObjs);\n  return comment;\n}\nfunction UpdateComment2(cobj, uid) {\n  if (cobj.collection_ref === void 0)\n    throw new Error(`UpdateComment cref is undefined ${cobj}`);\n  dc_comment_default.UpdateComment(cobj);\n  DeriveThreadedViewObjects(cobj.collection_ref, uid);\n  let commentVObjs = GetThreadedViewObjects(cobj.collection_ref, uid);\n  const cvobj = GetCommentVObj(cobj.collection_ref, cobj.comment_id);\n  if (cvobj === void 0)\n    throw new Error(\n      `ac-comment.UpdateComment could not find cobj ${cobj.comment_id}.  Maybe it hasn't been created yet? ${COMMENTVOBJS}`\n    );\n  cvobj.isMarkedRead = false;\n  dc_comment_default.MarkCommentUnread(cvobj.comment_id, uid);\n  cvobj.isBeingEdited = false;\n  m_DeRegisterCommentBeingEdited(cobj.comment_id);\n  cvobj.modifytime_string = GetDateString(cobj.comment_modifytime);\n  commentVObjs = commentVObjs.map(\n    (c) => c.comment_id === cvobj.comment_id ? cvobj : c\n  );\n  COMMENTVOBJS.set(cobj.collection_ref, commentVObjs);\n}\nfunction HandleUpdatedComments2(comments) {\n  dc_comment_default.HandleUpdatedComments(comments);\n}\nfunction RemoveComment2(parms) {\n  if (parms.collection_ref === void 0)\n    throw new Error(`RemoveComment collection_ref is undefined ${parms}`);\n  const queuedActions = dc_comment_default.RemoveComment(parms);\n  DeriveThreadedViewObjects(parms.collection_ref, parms.uid);\n  queuedActions.push({ collection_ref: parms.collection_ref });\n  return queuedActions;\n}\nfunction RemoveAllCommentsForCref2(parms) {\n  if (parms.collection_ref === void 0)\n    throw new Error(`RemoveAllCommentsForCref collection_ref is undefined ${parms}`);\n  const queuedActions = dc_comment_default.RemoveAllCommentsForCref(parms);\n  DeriveThreadedViewObjects(parms.collection_ref, parms.uid);\n  queuedActions.push({ collection_ref: parms.collection_ref });\n  return queuedActions;\n}\nfunction HandleRemovedComments2(comment_ids) {\n  dc_comment_default.HandleRemovedComments(comment_ids);\n}\nfunction GetUserName2(uid) {\n  return dc_comment_default.GetUserName(uid);\n}\nfunction GetCommentTypes2() {\n  return dc_comment_default.GetCommentTypes();\n}\nfunction GetCommentType2(slug) {\n  return dc_comment_default.GetCommentType(slug);\n}\nfunction GetDefaultCommentType2() {\n  return dc_comment_default.GetDefaultCommentType();\n}\nfunction GetCOMMENTS2() {\n  return dc_comment_default.GetCOMMENTS();\n}\nfunction GetComment2(cid) {\n  return dc_comment_default.GetComment(cid);\n}\nfunction GetReadby2(cid) {\n  return dc_comment_default.GetReadby(cid);\n}\nfunction GetCrefs2() {\n  return dc_comment_default.GetCrefs();\n}\n\n// _ur_addons/@addons-client.ts\nvar { ConsoleStyler } = client_esm_exports;\nvar PF = ConsoleStyler(\"UR/ADD\", \"TagPink\");\nvar CLASS2 = {\n  NetEndpoint: NetEndpoint2,\n  NetSocket: NetSocket2,\n  NetPacket: NetPacket2\n};\nfunction AddonClientTest() {\n  console.log(...PF(\"System Integration of new URSYS addon successful!\"));\n}\n//# sourceMappingURL=addons-client-cjs.js.map\n  })();\n});"]}